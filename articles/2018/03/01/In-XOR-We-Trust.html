<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>In XOR we trust</title>
  <meta name="description" content="This is the first set of exercises for theMatasano Challenge (also known asthe Cryptopals Challenge)It starts from the very begin, really easy, but it goes u...">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2018/03/01/In-XOR-We-Trust.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>In XOR we trust</h1>
<p class="subtitle">March 1, 2018</p>

<p>This is the first set of exercises for the
<a href="https://cryptopals.com/">Matasano Challenge</a> (also known as
the Cryptopals Challenge)</p>

<p>It starts from the very begin, really easy, but it goes up to more
challenging exercises quickly.</p>

<p>Ready?<label for="mn-92c40aed2262db60522dbf16855f07d8" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-92c40aed2262db60522dbf16855f07d8" class="margin-toggle" /><span class="marginnote"><strong>– Spoiler Alert! –</strong> </span> <em>Go!</em><!--more--></p>

<h2 id="warming-up">Warming up</h2>

<p>During this challenge I will be using and implementing a set of tools
to break crypo: <a href="https://pypi.org/project/cryptonita/">cryptonita</a></p>

<p>Working with bytes can be a mess so let’s use some nice object that
would help us in our journey.</p>

<p><label for="mn-ee164b1015e63dc6ecebfbbc78a0bf73" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-ee164b1015e63dc6ecebfbbc78a0bf73" class="margin-toggle" /><span class="marginnote">This unlocks the
<a href="https://cryptopals.com/sets/1/challenges/1">Convert hex to base 64</a>
challenge. </span></p>

<p>We can use <code class="highlighter-rouge">bytestring</code> or just <code class="highlighter-rouge">B</code> to convert strings encoded
in base 16 or 64 into bytes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita</span> <span class="kn">import</span> <span class="n">B</span>         <span class="c1"># byexample: +timeout=10
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="s">'49276d206b696c6c696e6720796f75'</span>
<span class="o">...</span>       <span class="s">'7220627261696e206c696b65206120'</span>
<span class="o">...</span>       <span class="s">'706f69736f6e6f7573206d757368726f6f6d'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="n">b</span><span class="s">'SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t'</span>
</code></pre></div></div>

<p>But <code class="highlighter-rouge">bytestring</code> is a little more than a decoder: it has a convenient
interface to to manipulate the bytes.</p>

<p>For example, you can perform a <code class="highlighter-rouge">xor</code> between two strings in
one instruction:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="s">'1c0111001f010100061a024b53535009181c'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="s">'686974207468652062756c6c277320657965'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">b</span><span class="s">'746865206B696420646F6E277420706C6179'</span>
</code></pre></div></div>

<p><label for="mn-10519915d378dfe67b28e42bec65755c" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-10519915d378dfe67b28e42bec65755c" class="margin-toggle" /><span class="marginnote">These last two examples solve the challenges
<a href="https://cryptopals.com/sets/1/challenges/2">Fixed XOR</a> and
<a href="https://cryptopals.com/sets/1/challenges/5">Implement repeating-key XOR</a> </span></p>

<p>Even you can perform the <code class="highlighter-rouge">xor</code> of two strings of different lengths: you
just say that the shorter string will be repeated to infinitum and everything
will work.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">plaintext</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="s">"Burning 'em, if you ain't quick and nimble</span><span class="se">\n</span><span class="s">"</span>
<span class="o">...</span>               <span class="s">"I go crazy when I hear a cymbal"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">key</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="s">"ICE"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">plaintext</span> <span class="o">^</span> <span class="n">key</span><span class="o">.</span><span class="n">inf</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="n">b</span><span class="s">'0B3637272A2B2E63622C2E69692A23693A2A3C6324202D623D63343C2A26226324272765272A282B2F20430A652E2C652A3124333A653E2B2027630C692B20283165286326302E27282F'</span>
</code></pre></div></div>

<h2 id="break-1-byte-key-xor">Break 1-byte key XOR</h2>

<h3 id="break-it-by-brute-force">Break it by Brute Force</h3>

<p>With a so small key space (1 byte means 256 different keys) we
can brute force the decryption of the ciphertext just trying
all the possible keys.</p>

<p>If we want to automate the process we will need a <em>scoring function</em>
to rank how likely the decrypted text is the real plaintext.</p>

<p>The scoring function will depend of the our knowledge about the real
plaintext.</p>

<p>If we assume that the text is written in <em>human ascii</em> we could assign a
higher value to the plaintexts that have only printable symbols (letters,
numbers, punctuation symbols and whitespaces).</p>

<p>A plain text with a byte <code class="highlighter-rouge">0xf1</code> is unlikely to be a <em>human ascii</em> text. (Such
weird bytes <em>could</em> be part of a human text using another encoding like
<code class="highlighter-rouge">utf-8</code>)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.scoring</span> <span class="kn">import</span> <span class="n">all_ascii_printable</span>         <span class="c1"># byexample: +timeout 10
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">all_ascii_printable</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="s">'hello!'</span><span class="p">))</span>
<span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">all_ascii_printable</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="s">'hi</span><span class="se">\x00</span><span class="s">!'</span><span class="p">))</span>
<span class="mi">0</span>
</code></pre></div></div>

<p>Now, the attack</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.attacks</span> <span class="kn">import</span> <span class="n">brute_force</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="s">'1b37373331363f78151b7f2b783'</span>
<span class="o">...</span>                <span class="s">'431333d78397828372d363c7837'</span>
<span class="o">...</span>                <span class="s">'3e783a393b3736'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">brute_force</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">all_ascii_printable</span><span class="p">,</span> <span class="n">key_space</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="mi">21</span>
</code></pre></div></div>

<p>Not bad, but we are smarter than this.</p>

<h3 id="frequency-attack">Frequency attack</h3>

<p>Brute forcing is expensive even for a small key space. And it is not
very cleaver either as we are not using any information about the plaintext to
our favor.</p>

<p><label for="mn-e542745fa1c33b6e8bc5c1b296a8835f" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-e542745fa1c33b6e8bc5c1b296a8835f" class="margin-toggle" /><span class="marginnote"><code class="highlighter-rouge">ETAOIN SHRDLU</code> Achievement Unlocked </span></p>

<p>If we assume that the plaintext is in English, it is likely that one of
the most common bytes in the ciphertext is actually <em>one of the most common</em>
bytes in English but encrypted.</p>

<p>The <code class="highlighter-rouge">xor</code> between them will give us the key or at least we will narrow
to a small subset of possible keys.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.attacks</span> <span class="kn">import</span> <span class="n">freq_attack</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">most_common_plain_ngrams</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="s">'etaoin shrdlu'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cipher_ngram_top</span> <span class="o">=</span> <span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">freq_attack</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">most_common_plain_ngrams</span><span class="p">,</span> <span class="n">cipher_ngram_top</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="mi">13</span>
</code></pre></div></div>

<p>We got 13 different possible keys, doing a small brute force we
can reduce the set further:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">brute_force</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">score_func</span><span class="o">=</span><span class="n">all_ascii_printable</span><span class="p">,</span>
<span class="o">...</span>                                 <span class="n">key_space</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">keys</span>
<span class="p">{</span><span class="s">'X'</span> <span class="o">-&gt;</span> <span class="mf">1.0000</span><span class="p">}</span>
</code></pre></div></div>

<p><label for="mn-06887d016fc2edf8d779de754dd3ec94" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-06887d016fc2edf8d779de754dd3ec94" class="margin-toggle" /><span class="marginnote"><a href="https://cryptopals.com/sets/1/challenges/3">Single-byte XOR cipher</a>
challenge done. </span></p>

<p>Finally, the plaintext is</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ciphertext</span> <span class="o">^</span> <span class="n">B</span><span class="p">(</span><span class="s">'X'</span><span class="p">)</span><span class="o">.</span><span class="n">inf</span><span class="p">()</span>
<span class="s">"Cooking MC's like a pound of bacon"</span>
</code></pre></div></div>




    </article>
    <span class="print-footer">In XOR we trust - March 1, 2018 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
