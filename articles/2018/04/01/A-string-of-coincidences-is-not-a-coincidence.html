<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="description" content="A string of coincidences is not a coincidence A cipher is semantically secure if given a randomly chosen key, its ciphertext cannot be distinguishable from a truly random string. Detecting a ciphertext from a pool is enough to consider the cipher as not secure even of we can’t break it. In the following pool of random strings one is actually a ciphertext that is the encryption of a plaintext using a single-byte key. – Spoiler Alert! – This is obviously a poor and not secure encryption mechanism; let’s find the ciphertext then!">

  
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      
          "@type": "BlogPosting",
          "headline": "A string of coincidences is not a coincidence",
          
          
          "datePublished": "2018-04-01T00:00:00+00:00",
          "dateModified": "2018-04-01T00:00:00+00:00",
          

          "author": [{
              "@type": "Person",
              "name": "Martin Di Paola",
              "url": "https://book-of-gehn.github.io"
            }]
      
    }
  </script>


  

  <title>A string of coincidences is not a coincidence</title>

  <link rel="icon" type="image/x-icon" href="/img/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" href="https://book-of-gehn.github.io/rss.xml">

  <link rel="canonical" href="https://book-of-gehn.github.io/articles/2018/04/01/A-string-of-coincidences-is-not-a-coincidence.html">

  <link href='/css/load-lato-fonts.min.css' rel='stylesheet' type='text/css'>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      //root: "/js/MathJax-2.7.7",
      extensions: ["tex2jax.js"],
      jax: ["input/TeX","output/HTML-CSS"],
      tex2jax: {inlineMath: [["\\(","\\)"]]},
      TeX: {
        Macros: {
          
        }
      }
    });
  </script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js' async></script>

  <script src="/js/jquery-3.6.0.min.js"></script>

  <script src='/js/underscore-1.9.1.min.js' ></script>

  <script src='/js/d3-7.4.2.min.js'></script>

  <script src='/js/venn/venn-0.2.14.min.js'></script>
  <script src='/js/venn/helper.min.js'></script>

  <script src='/js/fix_syntax_highlight.min.js'></script>
  <link rel="stylesheet" type="text/css" href="/css/tufte.min.css">
  <link rel="stylesheet" type="text/css" href="/css/latex.min.css">

  <link rel="stylesheet" type="text/css" href="/css/font-awesome-5.min.css">

  <script src='/js/lunr-2.3.9.min.js'></script>
  <script src='/js/search_index.js'></script>
  <script src='/js/search.min.js'></script>
</head>
<body>
<header>
                <hgroup class="header-group">
        <h1 class="header-title"><a href="/">The Book of Gehn</a></h1>
                </hgroup>
                <ul class="header-list">
                    <li><a href="https://byexamples.github.io">byexample</a></li>
                    <li><a href="https://bisturi.github.io">bisturi</a></li>
                    <li>
                        <a class="raw_link" href="/atom.xml"><img height="16px" width="16px" src="/img/rss-32px.png" /></a>
                        <a class="raw_link" href="https://github.com/eldipa"><img height="16px" width="16px" src="/img/github.png" /></a>
                    </li>
                </ul>
        
        

    

</header>
<article class="group">
<h1>
A string of coincidences is not a coincidence
</h1>
<p class="subtitle">
April 1, 2018
</p>
<p>A cipher is <em>semantically secure</em> if given a randomly chosen key, its ciphertext cannot be distinguishable from a truly random string.</p>
<p>Detecting a ciphertext from a pool is enough to consider the cipher as not secure even of we can’t break it.</p>
<p>In the following pool of random strings one is actually a ciphertext that is the <code><span class="highlight-candombe-inline"><span class="n">xor</span></span></code> encryption of a plaintext using a single-byte key.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita</span> <span class="kn">import</span> <span class="n">B</span><span class="p">,</span> <span class="n">load_bytes</span>     <span class="c1"># byexample: +timeout=10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ciphertexts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">load_bytes</span><span class="p">(</span><span class="s1">&#39;./posts/matasano/assets/4.txt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="mi">16</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div>

<p><label for='KiotLSBTcG9pbGVyIEFsZXJ0ISAtLSoqbWFyZ2lubm90ZXM=' class='margin-toggle'> &#8853;</label>
<input type='checkbox' id='KiotLSBTcG9pbGVyIEFsZXJ0ISAtLSoqbWFyZ2lubm90ZXM=' class='margin-toggle'/>
<span class='marginnote'>
<strong>– Spoiler Alert! –</strong>
</span></p>
<p>This is obviously a poor and not secure encryption mechanism; let’s find the ciphertext then!<!--more--></p>
<h2 id="distinguish-a-ciphertext">Distinguish a ciphertext</h2>
<p><label for='CltEZXRlY3Qgc2luZ2xlLWNoYXJhY3RlciBYT1JdKGh0dHBzOi8vY3J5cHRvcGFscy5jb20vc2V0cy8xL2NoYWxsZW5nZXMvNCkKY2hhbGxlbmdlCm1hcmdpbm5vdGVz' class='margin-toggle'> &#8853;</label>
<input type='checkbox' id='CltEZXRlY3Qgc2luZ2xlLWNoYXJhY3RlciBYT1JdKGh0dHBzOi8vY3J5cHRvcGFscy5jb20vc2V0cy8xL2NoYWxsZW5nZXMvNCkKY2hhbGxlbmdlCm1hcmdpbm5vdGVz' class='margin-toggle'/>
<span class='marginnote'>
<a href="https://cryptopals.com/sets/1/challenges/4">Detect single-character XOR</a> challenge
</span></p>
<p>The basic idea is that some patterns in the plaintext are propagated to the ciphertext and those we will be enough to distinguish it from the rest of the pool.</p>
<h3 id="index-of-coincidence">Index of coincidence</h3>
<p>One possibility could be that the ciphertext shows more repeated bytes (something that clearly is not random).</p>
<p>A string with a <em>lot of coincidences is not a coincidence</em>.</p>
<p>For this we can calculate the <a href="https://en.wikipedia.org/wiki/Index_of_coincidence">index of coincidences</a>.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.metrics</span> <span class="kn">import</span> <span class="n">icoincidences</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">icoincidences</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="c1"># higher values, less random</span>
<span class="p">[(</span><span class="mf">0.02298</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">101</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.02988</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">102</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.04597</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">170</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;Index of Coincidence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div>

<h3 id="entropy">Entropy</h3>
<p>The entropy measures the information that a sequence has based on the probability of its events.</p>
<p>If all the events are equally likely, the sequence looks more random and carry more information (or it has less redundancy if you want).</p>
<p>The entropy is defined as:</p>
$$S=\sum_{\forall p_{x}}p_{x}\textrm{log}_{n}\left(p_{x}\right)$$
<p>Where each \(p_{x}\) is the probability of the event \(x\) and \(n\) is the number of event types.</p>
<p>What is an event, it is up to you.</p>
<h3 id="entropy-at-the-bit-level">Entropy at the bit level</h3>
<p>The entropy is not an intrinsic value of the sample, it is a value relative to a particular model.</p>
<p>If we are interested in only the individual bits we could set two possible events: <code><span class="highlight-candombe-inline"><span class="mi">0</span></span></code> and <code><span class="highlight-candombe-inline"><span class="mi">1</span></span></code>.</p>
<p>We can calculate the probability of each event as:</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">bit_freq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">ones</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">count_1s</span><span class="p">()</span>
<span class="o">...</span>     <span class="n">zeros</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="n">ones</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">ones</span>
</code></pre></div>

<p>A truly random string should yield <code><span class="highlight-candombe-inline"><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span></span></code> (half bits are <code><span class="highlight-candombe-inline"><span class="mi">1</span></span></code>, the other half are <code><span class="highlight-candombe-inline"><span class="mi">0</span></span></code>.</p>
<p>Under this module, we can calculate the entropy for all the strings in the pool:</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">bit_freq</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># lower values, less random</span>
<span class="p">[(</span><span class="mf">0.9097</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">311</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.9182</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">230</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.9377</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">68</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.9377</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">138</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;Entropy bit-level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div>

<p>The entropy defined as we did performed poorly as discriminant.</p>
<p>This is because we are are considering the bits independently one of each other: the sequence <code><span class="highlight-candombe-inline"><span class="mi">0101010101</span></span></code> has the same amount of <code><span class="highlight-candombe-inline"><span class="mi">1</span></span></code> and <code><span class="highlight-candombe-inline"><span class="mi">0</span></span></code> so its a entropy is 1.0 and it would look random because the model doesn’t capture a pattern of more than one bit.</p>
<p>To be effective, <em>the entropy must have a useful model</em>.</p>
<h3 id="entropy-at-the-byte-level">Entropy at the byte level</h3>
<p>We could change the model as define the byte as the unit for the entropy:</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">byte_freq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">256</span>
<span class="o">...</span>     <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
<span class="o">...</span>         <span class="n">f</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">f</span>
</code></pre></div>

<p>This time, the entropy is:</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">byte_freq</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># lower values, less random</span>
<span class="p">[(</span><span class="mf">0.4983211558075781</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.5399878224742447</span><span class="p">,</span> <span class="mi">102</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.5404039285997025</span><span class="p">,</span> <span class="mi">101</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.548737261933036</span><span class="p">,</span> <span class="mi">232</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;Entropy byte-level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div>

<p>Much better!</p>
<h3 id="entropy-at-xor-level">Entropy at xor level</h3>
<p>Remember that the ciphertext that we are looking for was encrypted doing a xor with a single byte.</p>
<p>Therefore we could use the first byte and xor it with the rest of the string.</p>
<p>If the string is random, the xor will just shuffle more bits and the string will remain random.</p>
<p>But if it is not the xor will remove the entropy added by the key from the ciphertext and it should be easier to spot because the resulting string will be the xor of two ASCII strings.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ascii_bytes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">127</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ascii_xor_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ascii_bytes</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ascii_bytes</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">in_xor_set_freq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
<span class="o">...</span>     <span class="n">y</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">inf</span><span class="p">()</span> <span class="o">^</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="o">...</span>     <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
<span class="o">...</span>         <span class="n">f</span><span class="p">[</span><span class="n">b</span> <span class="ow">in</span> <span class="n">ascii_xor_set</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">f</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">in_xor_set_freq</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c1"># lower values, less random</span>
<span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">149</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">165</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">195</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">225</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">230</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">289</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">295</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.21639693245126465</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;Entropy xor-level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div>

<p><label for='Ckkgd29uZGVyLCB3aGF0IHdvdWxkIGhhcHBlbiBpZiBpbnN0ZWFkIG9mIHhvcmluZyB1c2luZyB0aGUgZmlyc3QgYnl0ZQp3ZSB0cnkgdGhlbiB0aGUgc2Vjb25kIGJ5dGUgYW5kIHRoZW4gdGhlIHRoaXJkLiBXaWxsIHRoZXNlIGFncmVlPyBDb3VsZCB3ZSB1c2UKdGhlbSB0byByZW1vdmUgZmFsc2UgcG9zaXRpdmVzPwptYXJnaW5ub3Rlcw==' class='margin-toggle'> &#8853;</label>
<input type='checkbox' id='Ckkgd29uZGVyLCB3aGF0IHdvdWxkIGhhcHBlbiBpZiBpbnN0ZWFkIG9mIHhvcmluZyB1c2luZyB0aGUgZmlyc3QgYnl0ZQp3ZSB0cnkgdGhlbiB0aGUgc2Vjb25kIGJ5dGUgYW5kIHRoZW4gdGhlIHRoaXJkLiBXaWxsIHRoZXNlIGFncmVlPyBDb3VsZCB3ZSB1c2UKdGhlbSB0byByZW1vdmUgZmFsc2UgcG9zaXRpdmVzPwptYXJnaW5ub3Rlcw==' class='margin-toggle'/>
<span class='marginnote'>
I wonder, what would happen if instead of xoring using the first byte we try then the second byte and then the third. Will these agree? Could we use them to remove false positives?
</span></p>
<p>Interesting, this method has more false positives than others but at the same time, this method makes a clear distinction between a few really non random strings and the rest of the strings in the pool.</p>
<h3 id="kolmogorov-complexity">Kolmogorov complexity</h3>
<p>As an alternative way to see this, a random string cannot be compressed. So the string with the shortest compressed version will be likely to be a non-random string.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">lzma</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">compress_score</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">lzma</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(),</span> <span class="n">lzma</span><span class="o">.</span><span class="n">FORMAT_ALONE</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">compress_score</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># lower values, less random</span>
<span class="p">[(</span><span class="mi">53</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span> <span class="p">(</span><span class="mi">55</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">55</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;Kolmogorov Complexity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div>

<p>It works…. slowly, but it works.</p>
<h2 id="break-it">Break it</h2>
<p>Now let’s break the ciphertext using a frequency attack (implemented in <a href="https://pypi.org/project/cryptonita/">cryptonita</a>).</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.scoring</span> <span class="kn">import</span> <span class="n">all_ascii_printable</span>         <span class="c1"># byexample: +timeout 10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.attacks</span> <span class="kn">import</span> <span class="n">brute_force</span><span class="p">,</span> <span class="n">freq_attack</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">most_common_plain_ngrams</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="s1">&#39;etaoin shrdlu&#39;</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">ciphertexts</span><span class="p">[</span><span class="mi">170</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">freq_attack</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">most_common_plain_ngrams</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">brute_force</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">all_ascii_printable</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div>

<p>We narrow this down to 3 keys only. I’ll do a little cheat here</p>
<div class="highlight-candombe"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">B</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">keys</span>
<span class="kc">True</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">ciphertext</span> <span class="o">^</span> <span class="n">B</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">inf</span><span class="p">()</span>
<span class="s1">&#39;Now that the party is jumping</span><span class="se">\n</span><span class="s1">&#39;</span>
</code></pre></div>

<h2 id="conclusion">Conclusion</h2>
<p>Claiming that a string is uniformly random if <em>far from trivial</em>.</p>
<p>Even the NSA battery tests for randomness fail to measure the randomness of crafted strings.</p>
<p>Here is the plot of the scores calculated by the different methods:</p>
<p><figure class='fullwidth'><object style="width: 100%;" class='fullwidth' align='middle' data='/img/matasano/scores_by_method.svg' type='image/svg+xml'></object>
<figcaption>
Scores by method. Notice how the element 170th gets the lower value in most cases indicating that the string is not random.
</figcaption></figure></p>
<p><br /></p>
<!--
>>> import sys
>>> sys.path.append("./z/py/plotting")

>>> from plotting import plt, show                      # byexample: +timeout=20
>>> import pandas as pd                                 # byexample: +timeout=20

>>> methods = pd.DataFrame(methods)

>>> def min_max_normalizer(c):
...     return (c - c.min()) / (c.max() - c.min())

>>> methods = methods.apply(min_max_normalizer, axis=0)

>>> with show(save='./posts/matasano/scores_by_method.svg', columns = 2, transparent = True): # byexample: +timeout=600 +skip
...     axes = methods.plot(style='o', subplots=True, layout=(3, 2))
...
...     _ = [ax.vlines(170, 0, 1, linestyles='dashed') for ax in axes.flat]
-->
<p class="small-subtitle-with-top-margin">
Related tags: <a href='https://book-of-gehn.github.io/?tag="cryptography"'>cryptography</a>, <a href='https://book-of-gehn.github.io/?tag="matasano"'>matasano</a>, <a href='https://book-of-gehn.github.io/?tag="cryptonita"'>cryptonita</a>, <a href='https://book-of-gehn.github.io/?tag="index coincidence"'>index coincidence</a>
</p>
<script src="https://utteranc.es/client.js"
        repo="book-of-gehn/book-of-gehn.github.io"
        issue-term="pathname"
        label="comments-utteranc"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
<span class="print-footer">A string of coincidences is not a coincidence - April 1, 2018 - Martin Di Paola</span>
<footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy;
            Martin Di Paola
        </span></br>
            <a class="raw_link" href="/atom.xml"><img height="16px" width="16px" src="/img/rss-32px.png" /></a>
            <a class="raw_link" href="https://github.com/eldipa"><img height="16px" width="16px" src="/img/github.png" /></a>
        <br>
        
        <a href="mailto:martinp.dipaola@gmail.com">martinp.dipaola@gmail.com</a></span></br> <br>
        
    </div>

    <img src='http://192.34.63.156:6127/img/http%3A//127.0.0.1%3A4000/articles/2018/04/01/A-string-of-coincidences-is-not-a-coincidence.html.png' onerror="this.style.display='none'" async></img>
</footer>
</body>
</html>
