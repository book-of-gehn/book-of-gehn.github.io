<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A string of coincidences is not a coincidence</title>
  <meta name="description" content="A cipher is semantically secure if given a randomly chosen key, its ciphertextcannot be distinguishable from a truly random string.Detecting a ciphertext fro...">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2018/04/01/A-string-of-coincidences-is-not-a-coincidence.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>A string of coincidences is not a coincidence</h1>
<p class="subtitle">April 1, 2018</p>

<p>A cipher is <em>semantically secure</em> if given a randomly chosen key, its ciphertext
cannot be distinguishable from a truly random string.</p>

<p>Detecting a ciphertext from a pool is enough to consider
the cipher as not secure even of we can’t break it.</p>

<p>In the following pool of random strings one is actually a ciphertext
that is the <code class="highlighter-rouge">xor</code> encryption of a plaintext using a single-byte key.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita</span> <span class="kn">import</span> <span class="n">B</span><span class="p">,</span> <span class="n">load_bytes</span>     <span class="c1"># byexample: +timeout=10
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">ciphertexts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">load_bytes</span><span class="p">(</span><span class="s">'./assets/matasano/4.txt'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="mi">16</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div></div>

<p>This is obviously a poor and not secure encryption mechanism; let’s find
the ciphertext then!<label for="mn-92c40aed2262db60522dbf16855f07d8" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-92c40aed2262db60522dbf16855f07d8" class="margin-toggle" /><span class="marginnote"><strong>– Spoiler Alert! –</strong> </span><!--more--></p>

<h2 id="distinguish-a-ciphertext">Distinguish a ciphertext</h2>

<p><label for="mn-f8f3f53be00d01794d7164fdc3fd2016" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-f8f3f53be00d01794d7164fdc3fd2016" class="margin-toggle" /><span class="marginnote"><a href="https://cryptopals.com/sets/1/challenges/4">Detect single-character XOR</a>
challenge </span></p>

<p>The basic idea is that some patterns in the plaintext are propagated
to the ciphertext and those we will be enough to distinguish it from
the rest of the pool.</p>

<h3 id="index-of-coincidence">Index of coincidence</h3>

<p>One possibility could be that the ciphertext shows more repeated bytes
(something that clearly is not random).</p>

<p>A string with a <em>lot of coincidences is not a coincidence</em>.</p>

<p>For this we can calculate the
<a href="https://en.wikipedia.org/wiki/Index_of_coincidence">index of coincidences</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.scoring</span> <span class="kn">import</span> <span class="n">icoincidences</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">icoincidences</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="c1"># higher values, less random
</span><span class="p">[(</span><span class="mf">0.02298</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">101</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.02988</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">102</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.04597</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">170</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s">'Index of Coincidence'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="entropy">Entropy</h3>

<p>The entropy measures the information that a sequence has based on
the probability of its events.</p>

<p>If all the events are equally likely, the sequence looks more random
and carry more information (or it has less redundancy if you want).</p>

<p>The entropy is defined as:</p>

<script type="math/tex; mode=display">S=\sum_{\forall p_{x}}p_{x}\textrm{log}_{n}\left(p_{x}\right)</script>

<!-- *_ -->

<p>Where each <script type="math/tex">p_{x}</script> <!-- *_ --> is the probability of the event <script type="math/tex">x</script> and
<script type="math/tex">n</script> is the number of event types.</p>

<p>What is an event, it is up to you.</p>

<h3 id="entropy-at-the-bit-level">Entropy at the bit level</h3>

<p>The entropy is not an intrinsic value of the sample, it is a value relative
to a particular model.</p>

<p>If we are interested in only the individual bits we could set
two possible events: <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">1</code>.</p>

<p>We can calculate the probability of each event as:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">bit_freq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">ones</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">count_1s</span><span class="p">()</span>
<span class="o">...</span>     <span class="n">zeros</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="n">ones</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">ones</span>
</code></pre></div></div>

<p>A truly random string should yield <code class="highlighter-rouge">[n/2, n/2]</code> (half bits are <code class="highlighter-rouge">1</code>,
the other half are <code class="highlighter-rouge">0</code>.</p>

<p>Under this module, we can calculate the entropy for all
the strings in the pool:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="n">stats</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">bit_freq</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># lower values, less random
</span><span class="p">[(</span><span class="mf">0.9097</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">311</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.9182</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">230</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.9377</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">68</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.9377</span><span class="o">&lt;...&gt;</span><span class="p">,</span> <span class="mi">138</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s">'Entropy bit-level'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div></div>

<p>The entropy defined as we did performed poorly as discriminant.</p>

<p>This is because we are are considering the bits independently one of each
other: the sequence <code class="highlighter-rouge">0101010101</code> has the same amount of <code class="highlighter-rouge">1</code> and <code class="highlighter-rouge">0</code>
so its a entropy is 1.0 and it would look random because the model
doesn’t capture a pattern of more than one bit.</p>

<p>To be effective, <em>the entropy must have a useful model</em>.</p>

<h3 id="entropy-at-the-byte-level">Entropy at the byte level</h3>

<p>We could change the model as define the byte as the unit for the entropy:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">byte_freq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">256</span>
<span class="o">...</span>     <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
<span class="o">...</span>         <span class="n">f</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">f</span>
</code></pre></div></div>

<p>This time, the entropy is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">byte_freq</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># lower values, less random
</span><span class="p">[(</span><span class="mf">0.4983211558075781</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.5399878224742447</span><span class="p">,</span> <span class="mi">102</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.5404039285997025</span><span class="p">,</span> <span class="mi">101</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.548737261933036</span><span class="p">,</span> <span class="mi">232</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s">'Entropy byte-level'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div></div>

<p>Much better!</p>

<h3 id="entropy-at-xor-level">Entropy at xor level</h3>

<p>Remember that the ciphertext that we are looking for was encrypted doing
a xor with a single byte.</p>

<p>Therefore we could use the first byte and xor it with the rest of the
string.</p>

<p>If the string is random, the xor will just shuffle more bits and the string
will remain random.</p>

<p>But if it is not the xor will remove the entropy added by the key from the
ciphertext and it should be easier to spot because the resulting string
will be the xor of two ASCII strings.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ascii_bytes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">127</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ascii_xor_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ascii_bytes</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ascii_bytes</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">in_xor_set_freq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
<span class="o">...</span>     <span class="n">y</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">inf</span><span class="p">()</span> <span class="o">^</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="o">...</span>     <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
<span class="o">...</span>         <span class="n">f</span><span class="p">[</span><span class="n">b</span> <span class="ow">in</span> <span class="n">ascii_xor_set</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">f</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">in_xor_set_freq</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c1"># lower values, less random
</span><span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">149</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">165</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">195</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">225</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">230</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">289</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">295</span><span class="p">),</span>
 <span class="p">(</span><span class="mf">0.21639693245126465</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s">'Entropy xor-level'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div></div>

<p>Interesting, this method has more false positives than others but at the
same time, this method makes a clear distinction between a few really non
random strings and the rest of the strings in the pool.</p>

<h3 id="kolmogorov-complexity">Kolmogorov complexity</h3>

<p>As an alternative way to see this, a random string cannot be compressed. So
the string with the shortest compressed version will be likely to be a
non-random string.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">lzma</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">compress_score</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">lzma</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(),</span> <span class="n">lzma</span><span class="o">.</span><span class="n">FORMAT_ALONE</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">compress_score</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ciphertexts</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_and_indexes</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># lower values, less random
</span><span class="p">[(</span><span class="mi">53</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span> <span class="p">(</span><span class="mi">55</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">55</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">methods</span><span class="p">[</span><span class="s">'Kolmogorov Complexity'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">]</span>
</code></pre></div></div>

<p>It works…. slowly, but it works.</p>

<h2 id="break-it">Break it</h2>

<p>Now let’s break the ciphertext using a frequency attack (implemented in
<a href="https://pypi.org/project/cryptonita/">cryptonita</a>).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.scoring</span> <span class="kn">import</span> <span class="n">all_ascii_printable</span>         <span class="c1"># byexample: +timeout 10
</span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.attacks</span> <span class="kn">import</span> <span class="n">brute_force</span><span class="p">,</span> <span class="n">freq_attack</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">most_common_plain_ngrams</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="s">'etaoin shrdlu'</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">ciphertexts</span><span class="p">[</span><span class="mi">170</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">freq_attack</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">most_common_plain_ngrams</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">brute_force</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">all_ascii_printable</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div></div>

<p>We narrow this down to 3 keys only. I’ll do a little cheat here</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">B</span><span class="p">(</span><span class="s">'5'</span><span class="p">)</span> <span class="ow">in</span> <span class="n">keys</span>
<span class="bp">True</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">ciphertext</span> <span class="o">^</span> <span class="n">B</span><span class="p">(</span><span class="s">'5'</span><span class="p">)</span><span class="o">.</span><span class="n">inf</span><span class="p">()</span>
<span class="s">'Now that the party is jumping</span><span class="se">\n</span><span class="s">'</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Claiming that a string is uniformly random if <em>far from trivial</em>.</p>

<p>Even the NSA battery tests for randomness fail to measure the randomness
of crafted strings.</p>

<p>Here is the plot of the scores calculated by the different methods:</p>

<figure class="fullwidth"><img src="/book-of-gehn/assets/matasano/scores_by_method.png" /><figcaption>Scores by methods. Notice how the the element 170th gets the lower value in most cases indicating that the string is not random.</figcaption></figure>

<p><br /></p>

<!--
>>> import sys
>>> sys.path.append("./assets/plotting")

>>> from plotting import plt, show                      # byexample: +timeout=20
>>> import pandas as pd                                 # byexample: +timeout=20

>>> methods = pd.DataFrame(methods)

>>> def min_max_normalizer(c):
...     return (c - c.min()) / (c.max() - c.min())

>>> methods = methods.apply(min_max_normalizer, axis=0)

>>> with show(save='./assets/matasano/scores_by_method.png', latexify_kargs={'columns':2}): # byexample: +timeout=600 +skip
...     axes = methods.plot(style='o', subplots=True, layout=(3, 2))
...
...     _ = [ax.vlines(170, 0, 1, linestyles='dashed') for ax in axes.flat]
-->



    </article>
    <span class="print-footer">A string of coincidences is not a coincidence - April 1, 2018 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
