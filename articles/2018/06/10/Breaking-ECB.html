<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Breaking ECB</title>
  <meta name="description" content="In the previous post we builtan ECB/CBC oracle;now it’s time to take this to the next level andbreak ECB one byte at time. ⊕– Spoiler Alert! – .">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2018/06/10/Breaking-ECB.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>Breaking ECB</h1>
<p class="subtitle">June 10, 2018</p>

<p>In the previous post we built
<a href="/book-of-gehn/articles/2018/06/09/ECB-CBC-Oracle.html">an ECB/CBC oracle</a>;
now it’s time to take this to the next level and
break ECB <a href="https://cryptopals.com/sets/2/challenges/14">one byte at time</a>.
<label for="mn-92c40aed2262db60522dbf16855f07d8" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-92c40aed2262db60522dbf16855f07d8" class="margin-toggle" /><span class="marginnote"><strong>– Spoiler Alert! –</strong> </span>.<!--more--></p>

<h3 id="generating-secrets">Generating secrets</h3>

<p>We will use the same setup of the
<a href="/book-of-gehn/articles/2018/06/09/ECB-CBC-Oracle.html">previous post</a>
but this time, our objective will decrypt ECB without the key.</p>

<p><label for="mn-de18d2f17e116f7c6c35bca4ce6261e7" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-de18d2f17e116f7c6c35bca4ce6261e7" class="margin-toggle" /><span class="marginnote">In fact, there are two challenges: the
<a href="https://cryptopals.com/sets/2/challenges/12">simple</a>
and the
<a href="https://cryptopals.com/sets/2/challenges/14">harder</a>
versions. We will break the harder of course. </span></p>

<p>Remember that we will have a secret payload appended to the attacker-controlled plaintext
and it is the objective for the
<a href="https://cryptopals.com/sets/2/challenges/14">byte-at-a-time ECB decryption challenge</a>..</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">"./assets/matasano"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita</span> <span class="kn">import</span> <span class="n">B</span><span class="p">,</span> <span class="n">load_bytes</span>     <span class="c1"># byexample: +timeout=10
</span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">challenge</span> <span class="kn">import</span> <span class="n">enc_ecb</span><span class="p">,</span> <span class="n">generate_config</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">20180610</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">16</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">secret</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="s">'Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg'</span> <span class="o">+</span>
<span class="o">...</span>            <span class="s">'aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq'</span> <span class="o">+</span>
<span class="o">...</span>            <span class="s">'dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg'</span> <span class="o">+</span>
<span class="o">...</span>            <span class="s">'YnkK'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">cfg</span> <span class="o">=</span> <span class="n">generate_config</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="n">block_size</span><span class="p">,</span> <span class="n">posfix</span><span class="o">=</span><span class="n">secret</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="c1"># pick the random prefix and let it fixed (constant)
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">cfg</span> <span class="o">=</span> <span class="n">generate_config</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span>
</code></pre></div></div>

<p>This is our encryption oracle:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">encryption_oracle</span><span class="p">(</span><span class="n">partial_plaintext</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">global</span> <span class="n">cfg</span>
<span class="o">...</span>     <span class="n">cfg</span> <span class="o">=</span> <span class="n">generate_config</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span> <span class="c1"># update the random attributes
</span><span class="o">...</span>
<span class="o">...</span>     <span class="n">block_size</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">kargs</span><span class="p">[</span><span class="s">'block_size'</span><span class="p">]</span>
<span class="o">...</span>
<span class="o">...</span>     <span class="c1"># prepend + append with two random strings; pad it later
</span><span class="o">...</span>     <span class="n">plaintext</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">partial_plaintext</span> <span class="o">+</span> <span class="n">cfg</span><span class="o">.</span><span class="n">posfix</span>
<span class="o">...</span>     <span class="n">plaintext</span> <span class="o">=</span> <span class="n">plaintext</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">pad_mode</span><span class="p">)</span>
<span class="o">...</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">enc_ecb</span><span class="p">(</span><span class="n">plaintext</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">block_size</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="block-alignment">Block alignment</h3>

<p>The prepended payload is constant but it is still unknown to the
us/adversary.</p>

<p>Before proceed we need to know for how many bytes our attacker-controlled
payload is misaligned.</p>

<p>Basically we start with a plaintext of <em>twice</em> the size of the block size
and we add one byte at time.</p>

<p>When we find two <em>consecutive</em> cipher blocks that are the same, we are done.</p>

<p>The amount of extra bytes that we added is the answer.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">alignment</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_size</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">c</span> <span class="o">=</span> <span class="n">encryption_oracle</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="s">'A'</span> <span class="o">*</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">alignment</span><span class="p">)))</span>
<span class="o">...</span>     <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">nblocks</span><span class="p">(</span><span class="n">block_size</span><span class="p">)</span><span class="o">.</span><span class="n">has_duplicates</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="o">...</span>         <span class="k">break</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">alignment</span>
<span class="mi">10</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="n">block_size</span> <span class="o">-</span> <span class="n">alignment</span>
<span class="bp">True</span>
</code></pre></div></div>

<h3 id="get-the-penguin">Get the penguin!</h3>

<p>Now, with our blocks aligned, we can set as our plaintext two identical blocks
but the last one will have one byte less.</p>

<p>This missing byte will be filled by the next plaintext byte <code class="highlighter-rouge">?</code>, unknown by us:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|----|----|----|----|
 AAAA AAA? .... ....
</code></pre></div></div>

<p>These two blocks will yield the same two cipher blocks only if the last byte
of the first block (<code class="highlighter-rouge">A</code>) is equal to the last byte of the second block (<code class="highlighter-rouge">?</code>)</p>

<p>We can extrapolate this testing for all the possible bytes <code class="highlighter-rouge">x</code>, until we find
an <code class="highlighter-rouge">x</code> that it is equals to <code class="highlighter-rouge">?</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|----|----|----|----|
 AAAx AAA? .... ....
    ^    ^
</code></pre></div></div>

<p>The first block (<code class="highlighter-rouge">AAAx</code>) is our <em>probe block</em> used to probe and find the
unknown byte <code class="highlighter-rouge">?</code>.</p>

<p>The second <em>partial</em> block (<code class="highlighter-rouge">AAA</code>) is used to align the unknown plaintext
so the <em>first unknown byte</em> is in place at the end of this block, named
as <em>align block</em>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  align block
      :::
|----|----|----|----|
 AAAx AAA? .... ....

AAAx    probe block
AAA     align block (3)
distance = 0

  align block
      :::
|----|---:|----|----|
 AAAa AAAa .... ....    'a' found
    ^    ^
</code></pre></div></div>

<p>The beauty of this is that no matter if the key used to encrypt changes,
this will work.</p>

<p>Even if the length of the prefix (plaintext <em>before</em> out controlled part)
changes, as long as it changes in a small range, it is just a matter of
trying more times.</p>

<p>After found the value of <code class="highlighter-rouge">?</code> we <em>shift</em> the unknown plaintext on byte to
the left and we continue breaking one byte at time.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  align block
      ::
|----|----|----|----|
 AAax AAa? .... ....    shift and test next byte
    ^    ^

AAax    probe block
AAa     align block (2)
distance = 0

      :
|----|----|----|----|
 Aabc Aabc .... ....    more bytes decrypted
    ^    ^

|----|----|----|----|
 abcx abc? .... ....    test next byte
    ^    ^

abcx    probe block
        align block (0)
distance = 0
</code></pre></div></div>

<p>After breaking <code class="highlighter-rouge">block_size</code> bytes, we cannot shift to the left further.</p>

<p>But what we can do is to add an extra block: the probe block will not
be testing its next block but the block that is 1 block to the right:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  align block
      :::
|----|----|----|----|
 bcdx AAAa bcd? ....    insert a pad block in the between, the test block
    ^         ^         is 1-block far form the probe block

bcdx    prob block
AAA     align block (3)
distance = 1


|----|----|----|----|
 bcde AAAa bcde ....    'e' found
    ^         ^
</code></pre></div></div>

<p>And the cycle repeats again:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  align block
      ::
|----|----|----|----|
 cdex AAab cde? ....    shift and test next byte
 ^^^^ ^^

cdex    probe block
AA      align block 2
distance = 1
</code></pre></div></div>

<p>The following is an implementation of the previous algorithm from
<a href="https://pypi.org/project/cryptonita/">cryptonita</a>
that breaks the ECB cipher using a oracle.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">cryptonita.attacks.block_ciphers</span> <span class="kn">import</span> <span class="n">decrypt_ecb_tail</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">decrypt_ecb_tail</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">encryption_oracle</span><span class="p">)</span>  <span class="c1"># byexample: +timeout 10
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">unpad</span><span class="p">(</span><span class="s">'pkcs#7'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">==</span> <span class="n">secret</span>
<span class="bp">True</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>   <span class="c1"># byexample: +norm-ws
</span><span class="s">"Rollin' in my 5.0</span><span class="se">\n</span><span class="s">With my rag-top down so my hair can blow</span><span class="se">\n</span><span class="s">The girlies on</span><span class="err">
</span><span class="s">standby waving just to say hi</span><span class="se">\n</span><span class="s">Did you stop? No, I just drove by</span><span class="se">\n</span><span class="s">"</span>
</code></pre></div></div>




    </article>
    <span class="print-footer">Breaking ECB - June 10, 2018 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
