<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lock-Free Queue - Part I</title>
  <meta name="description" content="While implementing a bounded queue or ring buffer in a single-threaduniverse is relatively easy, doing the same when you havetwo threads, the implementation ...">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2020/03/22/Lock-Free-Queue-Part-I.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>Lock-Free Queue - Part I</h1>
<p class="subtitle">March 22, 2020</p>

<p>While implementing a bounded queue or <em>ring buffer</em> in a single-thread
universe is relatively easy, doing the same when you have
two threads, the implementation of a lock-free queue
is <em>more challenging</em>.</p>

<figure><figcaption><span></span></figcaption><img style="" src="/book-of-gehn/assets/mpmc-queue/queue-sp-sc.png" /></figure>

<p>In this first part will analyse and implement a lock-free single-producer
single-consumer queue. A multi-producer multi-consumer queue is
described in the
<a href="/book-of-gehn/articles/2020/04/28/Lock-Free-Queue-Part-II.html">second part</a>.<!--more--></p>

<p>In a traditional queue we have two pointers:
the <em>head</em>, that points to the next free entry to write and the
<em>tail</em>, which points to the next entry ready to be read.</p>

<figure><figcaption><span>When a producer pushes a new data to the queue, she moves forward
the <em>head</em> and writes the data; meanwhile the consumer
reads the data and moves forward the <em>tail</em>.
</span></figcaption><img src="/book-of-gehn/assets/mpmc-queue/queue-data.png" /></figure>

<p><label for="mf-d26917559fb6cef03a9c838a1c5b70ed" class="margin-toggle ">⊕</label><input type="checkbox" id="mf-d26917559fb6cef03a9c838a1c5b70ed" class="margin-toggle " /><span class="marginnote "><img class="fullwidth" alt="Full queue" src="/book-of-gehn/assets/mpmc-queue/queue-full.png" />  <br />Full queue. One entry is always left empty to differentiate a
full queue from an empty queue.
<br />
<a href="/book-of-gehn/articles/2018/09/16/Ouroboros-Circular-Buffer.html">Other implementations</a>
do not waste this entry.</span></p>

<p>The pointers serve as stop-markers: the producer will not write if
the head points to an entry that is immediately before the entry
pointed by the head; the consumer will not read if the tail and the
head are pointing to the same entry.</p>

<p><label for="mf-cdd9896fded24335cbc1f13fa08a7234" class="margin-toggle ">⊕</label><input type="checkbox" id="mf-cdd9896fded24335cbc1f13fa08a7234" class="margin-toggle " /><span class="marginnote "><img class="fullwidth" alt="Empty queue" src="/book-of-gehn/assets/mpmc-queue/queue-empty.png" />  <br />Empty queue. When head and tail pointers are the same there
is not ambiguity.</span></p>

<p>In the first case we say that the queue is full; in the second, the
queue is empty.</p>

<p>But if we want to make the queue thread safe without using locks we need
to make the push and the pop atomic.</p>

<p>And here is the problem: if a producer store the data <em>and later</em> moves
the head, another producer will see the <em>old</em> head in between and
store <em>her</em> data in the same place overwriting the first one.</p>

<p><label for="mn-3e2d4fd4ddc1089f194fc7bedc3f9e87" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-3e2d4fd4ddc1089f194fc7bedc3f9e87" class="margin-toggle" /><span class="marginnote">You may think that this cannot happen because we have only one producer.
<br />
And you are correct except for the memory reorders.
<br />
We cannot longer guarantee that the head was moved <em>after</em> writing
the data even if the code say so. Keep reading. </span></p>

<p>Changing the order doesn’t fix the problem: a producer may move the head
before writing, trying to <em>reserver</em> the space but now a consumer may forward
the tail before the data was actually written reading entries that are empty.</p>

<p>The problem is that the write <strong>and</strong> the move of the head is not a single
atomic action.</p>

<p>The same happen for reading.</p>

<p>The key to resolve this is to have two heads and two tails.</p>

<h2 id="reserve-commit">Reserve-Commit</h2>

<p>Both the producer and the consumer need their own head and tail.</p>

<p>The producer moves her head to <em>reserve</em> the space so other writers will
begin to write starting from <em>that</em> point.</p>

<p>At the same time the consumer will not forward beyond the <em>producer’s tail</em>.</p>

<p>Only when the producer finishes, she will move forward her <em>tail</em>,
<em>commiting</em> the change and allowing the readers to proceed.</p>

<figure><figcaption><span></span></figcaption><img src="/book-of-gehn/assets/mpmc-queue/queue-sp-sc.png" /></figure>

<p>The consumer does something similar: moving the consumer’s head
<em>reserves</em> the entries to read so other readers will not pop the same data;
and the consumer’s tail serves as a stop-marker for the writers.</p>

<p>Now, the trick is in how to move those pointers atomically.</p>

<h2 id="single-consumer-single-producer-queue-buggy-version">Single-consumer single-producer queue (buggy version)</h2>

<p>Let’s draft the <code class="highlighter-rouge">push()</code> function:</p>

<p><label for="mn-010165af4a20bf60d85e33384c69c353" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-010165af4a20bf60d85e33384c69c353" class="margin-toggle" /><span class="marginnote">Pseudo-C code, for simplification.
The full code can be found in the
<a href="https://github.com/eldipa/loki">loki library</a>.
 </span></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">old_prod_head</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span><span class="p">;</span>
    <span class="n">cons_tail</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_tail</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">free_entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="n">cons_tail</span> <span class="o">-</span> <span class="n">old_prod_head</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_entries</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="n">free_entries</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_entries</span> <span class="o">||</span> <span class="n">free_entries</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EAGAIN</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">new_prod_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span> <span class="o">=</span> <span class="n">new_prod_head</span><span class="p">;</span>

    <span class="c1">// write the data</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span> <span class="o">=</span> <span class="n">new_prod_head</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As we said before we have the producer’s head and the consumer’s
tail pointers.</p>

<p>We load them and check that if there are enough free entries for
pushing <code class="highlighter-rouge">len</code> data. <code class="highlighter-rouge">capacity</code> here is the size of the queue minus
one ensuring that a producer’s head will never reach the consumer’s
tail in a push.</p>

<p>If we have room, we update the producer’s head to the new value:
now the consumer had reserved the space between her tail and head
pointers to write the data.</p>

<p>After the write, the producer update her tail pointer so the consumer
can move forward and consume the new available data.</p>

<h2 id="atomic-loads-and-stores">Atomic loads and stores</h2>

<p>In a single-producer, the head is only modified by a single thread
but now, it can be modified by multiple producers.</p>

<p>To ensure a consistent value, the producer’s tail must be updated (<em>store</em>)
atomically so the consumer will not read an incomplete value.</p>

<p>This applies for consumer’s head too: the producer must <em>load</em> it atomically.</p>

<p><label for="mn-7f158100a862fcb24c03655593ee9458" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-7f158100a862fcb24c03655593ee9458" class="margin-toggle" /><span class="marginnote">The compiler may assume that <code class="highlighter-rouge">q-&gt;prod_tail</code> is never read
so it could strip the store off. Under a single thread scenario
this is correct; in a multithreading scenario this is a disaster. </span></p>

<p>In some processors the loads and stores to <code class="highlighter-rouge">uint32_t</code>
are atomic, however that’s not enough: we also need to prevent
the <em>compiler</em> from optimize them.</p>

<p>We <em>really need</em> that those loads and stores happen even if the compiler thinks
that they are not needed.</p>

<p><label for="mn-0f9151a75d79a00e3bbccb3b762f67a2" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-0f9151a75d79a00e3bbccb3b762f67a2" class="margin-toggle" /><span class="marginnote"><a href="/book-of-gehn/articles/2020/02/07/Compiler-Optimizations-under-RC.html">Take at look</a>
of what <code class="highlighter-rouge">volatile</code> does.
<br />
See also the comments about this in
<a href="https://en.cppreference.com/w/cpp/atomic/memory_order#Relationship_with_volatile">cppreference</a> </span></p>

<p>For that reason we declare them as <code class="highlighter-rouge">volatile</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">queue_t</span> <span class="p">{</span>
    <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">prod_head</span><span class="p">;</span>
    <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">prod_tail</span><span class="p">;</span>

    <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">cons_head</span><span class="p">;</span>
    <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">cons_tail</span><span class="p">;</span>
    <span class="c1">// ...</span>
</code></pre></div></div>
<p><label for="mn-2221e14980e23ce2393a9a39f9b55739" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-2221e14980e23ce2393a9a39f9b55739" class="margin-toggle" /><span class="marginnote">This is what
<a href="http://git.dpdk.org/dpdk/tree/lib/librte_ring/rte_ring_c11_mem.h">DPDK</a> does
while the
<a href="https://svnweb.freebsd.org/base/release/8.0.0/sys/sys/buf_ring.h?revision=199625&amp;amp">FreeBSD version</a>
assumes loads and stores are atomic. </span></p>

<p>If the processor cannot guarantee atomic loads and stores, we can instruct
the compiler to generate code for that:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">old_prod_head</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
    <span class="c1">//....</span>
    <span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">,</span> <span class="n">new_prod_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="load-and-store-reorder">Load and store reorder</h2>

<p>Review the following:</p>

<p><label for="mn-c4a8003d30ffda9106bc21c653c4787b" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-c4a8003d30ffda9106bc21c653c4787b" class="margin-toggle" /><span class="marginnote">We require the size of the queue
to be a power of 2: entry access through the head/tail pointer
is masked <code class="highlighter-rouge">size-1</code> instead with module of <code class="highlighter-rouge">size</code>.
 </span></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span> <span class="o">=</span> <span class="n">new_prod_head</span><span class="p">;</span>
</code></pre></div></div>

<p>What’s wrong?</p>

<p>The compiler may reorder the store of the tail to <em>happen before</em>
the actual write of the data. Even if the compiler does not do that,
the CPU may do it.</p>

<p><label for="mf-175a47fc061191f1816b3f3809a516ca" class="margin-toggle ">⊕</label><input type="checkbox" id="mf-175a47fc061191f1816b3f3809a516ca" class="margin-toggle " /><span class="marginnote "><img class="fullwidth" alt="Store reorder" src="/book-of-gehn/assets/mpmc-queue/reorder-2stores.png" />  <br /></span></p>

<p>This is a <em>store reorder</em>. A store is typically much expensive than
a load and they are moved <em>upwards</em> to start them sooner
or <em>downwards</em> to be delayed hoping to be merged with a further store.</p>

<p>Loads are subject of similar optimizations and the <code class="highlighter-rouge">volatile</code> keyword
will not prevent that: <code class="highlighter-rouge">volatile</code> works at the compiler level, has
no effect on the reorder made by the CPU.</p>

<p><label for="mn-1ff7ef67a450d48b42aab76812eae5ec" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-1ff7ef67a450d48b42aab76812eae5ec" class="margin-toggle" /><span class="marginnote">Beware that some barriers are at the compiler level only and here we
need to ensure that neither the compiler nor the CPU do something
<em>too smartish</em>. </span></p>

<p>We have the option to use a <em>full write barrier</em> in the middle
so all the stores that <em>happen before</em> of the tail update are
<em>perceived</em> by other threads as if they happen before the update</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// write the data</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">wmb</span><span class="p">();</span>  <span class="c1">// write memory barrier</span>

    <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span> <span class="o">=</span> <span class="n">new_prod_head</span><span class="p">;</span>
</code></pre></div></div>

<p>Nobody is saying that everything will happen in the same
<em>sequential</em> order, just that the notion of <code class="highlighter-rouge">A1, A2</code>, … happen before
<code class="highlighter-rouge">B1, B2</code>, … is preserved.</p>

<figure><figcaption><span><code class="highlighter-rouge">A1, A2, &lt;barrier&gt;, B1, B2</code> <em>and</em> <code class="highlighter-rouge">A2, A1, &lt;barrier&gt;, B2, B1</code>
are two valid outcomes: reorder on each side of the barrier are perfectly
valid (left).
<br />
Reorder across the barrier are not (right).</span></figcaption><img src="/book-of-gehn/assets/mpmc-queue/reorder-barrier.png" /></figure>

<p>A full write barrier is the nuke option as it prevents <em>any</em> store reorder
across that point for all the threads.</p>

<p>A more precise and efficient solution is possible in these days however.</p>

<h2 id="acquire---release-memory-model">Acquire - Release memory model</h2>

<p>Consider the last part of the <code class="highlighter-rouge">push</code> and the first part of the <code class="highlighter-rouge">pop</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// write the data</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span> <span class="o">=</span> <span class="n">new_prod_head</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">pop</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="n">old_cons_head</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_head</span><span class="p">;</span>
    <span class="n">prod_tail</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">ready_entries</span> <span class="o">=</span> <span class="n">prod_tail</span> <span class="o">-</span> <span class="n">old_cons_head</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ready_entries</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="n">ready_entries</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ready_entries</span> <span class="o">||</span> <span class="n">ready_entries</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<p>The producer updates (stores) her tail to <em>signal</em> the consumer that
can move forward.</p>

<p>The consumer is <em>waiting until</em> the producer’s tail is moved
forward so there are entries ready for reading.</p>

<p>There is no a real wait: the <code class="highlighter-rouge">pop()</code> just fails if there is nothing
to read but conceptually there is a <em>signal</em> and <em>wait</em> relationship
between the producer and the consumer on the producer’s tail pointer.</p>

<p>This is the same that happens when a thread <em>acquires</em> a mutex:
other thread will wait on it until the first thread <em>release</em> it.</p>

<p>The modern processors and compilers introduced this concept
in the Acquire - Release memory model.</p>

<p>We say that the consumer <em>acquires</em> the producer’s tail and the
producer <em>release</em> it.</p>

<p><label for="mn-d6e5b76856cea76f0330aad5e58ed433" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-d6e5b76856cea76f0330aad5e58ed433" class="margin-toggle" /><span class="marginnote">
<img class="fullwidth" style="float: right; margin-left: 10px;" src="/book-of-gehn/assets/mpmc-queue/reorder-what.png" />
<em>“No reads or writes in the current thread can be reordered
after this <code class="highlighter-rouge">RELEASE</code> store. All writes in the current thread are visible
in other threads that <code class="highlighter-rouge">ACQUIRE</code> (load) the same atomic variable.
No reads or writes in those threads can be reordered 
before that load either.”</em>
<br />
From <code class="highlighter-rouge">std::memory_order</code>, <a href="https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering">cppreference.com</a>
 </span></p>

<p>While a full barrier ensures a “happen before”
<em>across all the threads</em>, the <code class="highlighter-rouge">ACQUIRE</code> ensures that all the
stores of <em>that</em> thread that happen before the <code class="highlighter-rouge">ACQUIRE</code> will be
perceived than <em>happen before</em> by <em>only</em> the thread that is doing
the <code class="highlighter-rouge">RELEASE</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// ....</span>
    <span class="c1">// write the data</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">,</span> <span class="n">new_prod_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELEASE</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">pop</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="n">old_cons_head</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_head</span><span class="p">;</span>
    <span class="n">prod_tail</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">,</span> <span class="n">__ATOMIC_ACQUIRE</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">ready_entries</span> <span class="o">=</span> <span class="n">prod_tail</span> <span class="o">-</span> <span class="n">old_cons_head</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ready_entries</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="n">ready_entries</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ready_entries</span> <span class="o">||</span> <span class="n">ready_entries</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ....</span>
</code></pre></div></div>

<p><label for="mn-a73ebfb83acb9faf5ad2e0fa865593c0" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-a73ebfb83acb9faf5ad2e0fa865593c0" class="margin-toggle" /><span class="marginnote"><a href="http://git.dpdk.org/dpdk/tree/lib/librte_ring/rte_ring_c11_mem.h">DPDK</a> uses
this while the
<a href="https://svnweb.freebsd.org/base/release/8.0.0/sys/sys/buf_ring.h?revision=199625&amp;amp">FreeBSD version</a>
uses a full memory barrier.
 </span></p>

<p>Indeed the <code class="highlighter-rouge">RELEASE</code> ensures that the producer’s writes will be visible
by the consumer once she <code class="highlighter-rouge">ACQUIRE</code> the updated producer’s tail pointer
in a much efficient way that a full barrier</p>

<h2 id="single-producer-single-consumer-queue-final-version">Single-producer single-consumer queue (final version)</h2>

<p>This is the wrap up: a not only lock-free but a wait-free single-producer
single-consumer queue (or ring).</p>

<p>For those how want something compilable,
the final bits are in <a href="https://github.com/eldipa/loki">the loki library</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">old_prod_head</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span><span class="p">;</span>
    <span class="n">cons_tail</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_tail</span><span class="p">,</span> <span class="n">__ATOMIC_ACQUIRE</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">free_entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="n">cons_tail</span> <span class="o">-</span> <span class="n">old_prod_head</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_entries</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="n">free_entries</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_entries</span> <span class="o">||</span> <span class="n">free_entries</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOBUFS</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">new_prod_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span> <span class="o">=</span> <span class="n">new_prod_head</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">,</span> <span class="n">new_prod_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELEASE</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">old_cons_head</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_head</span><span class="p">;</span>
    <span class="n">prod_tail</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">,</span> <span class="n">__ATOMIC_ACQUIRE</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">ready_entries</span> <span class="o">=</span> <span class="n">prod_tail</span> <span class="o">-</span> <span class="n">old_cons_head</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ready_entries</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="n">ready_entries</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ready_entries</span> <span class="o">||</span> <span class="n">ready_entries</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">new_cons_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_cons_head</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_head</span> <span class="o">=</span> <span class="n">new_cons_head</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_cons_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>

    <span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_tail</span><span class="p">,</span> <span class="n">new_cons_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELEASE</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="open-questions">Open questions</h2>

<p>In the <a href="https://svnweb.freebsd.org/base/release/8.0.0/sys/sys/buf_ring.h?revision=199625&amp;amp">FreeBSD queue</a>
the <code class="highlighter-rouge">push()</code> and <code class="highlighter-rouge">pop()</code> are wrapped with <code class="highlighter-rouge">critical_enter()</code>
and <code class="highlighter-rouge">critical_exit()</code>.
I’m not sure exactly why. From the thread safety point
of view, they should not be necessary but they may be there for some reason.</p>

<h2 id="references">References</h2>

<p>Kip Macy implemented a <a href="https://svnweb.freebsd.org/base/release/8.0.0/sys/sys/buf_ring.h?revision=199625&amp;amp">buffer ring</a>
for FreeBSD. It was the base foundation
for DPDK’s <a href="http://git.dpdk.org/dpdk/tree/lib/librte_ring/rte_ring_c11_mem.h">rte_ring</a>.</p>

<p>Both were used as references along with</p>

<ul>
  <li><a href="https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering">Release-Acquire ordering, cppreference.com</a></li>
  <li><a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">GCC Atomics, gcc.gnu.org</a></li>
  <li><a href="https://doc.dpdk.org/guides-19.05/prog_guide/ring_lib.html">Ring library, doc.dpdk.org</a></li>
  <li><a href="https://www.youtube.com/watch?v=A8eCGOqgvH4">C++ and Beyond 2012: Herb Sutter - Atomic Weapons - Part 1</a></li>
  <li><a href="https://www.youtube.com/watch?v=KeLBd2EJLOU">C++ and Beyond 2012: Herb Sutter - Atomic Weapons - Part 2</a></li>
</ul>

<p>References at March 2020.</p>



    </article>
    <span class="print-footer">Lock-Free Queue - Part I - March 22, 2020 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
