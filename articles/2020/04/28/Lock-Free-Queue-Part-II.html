<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lock Free Queue - Part II</title>
  <meta name="description" content="If implementing a lock-free queue for only one producer and consumeris tricky, adding more producers and consumers moves thisto the next level.This is the co...">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2020/04/28/Lock-Free-Queue-Part-II.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>Lock Free Queue - Part II</h1>
<p class="subtitle">April 28, 2020</p>

<p>If implementing a lock-free queue for only one producer and consumer
is tricky, adding more producers and consumers moves this
to the next level.</p>

<p>This is the continuation of the
<a href="/book-of-gehn/articles/2020/03/22/Lock-Free-Queue-Part-I.html">lock-free single-producer single-consumer queue</a><!--more--></p>

<p>Not only we need to prevent race conditions between the producers and
the consumers but also between producers and between consumers.</p>

<h2 id="race-between-producers">Race between producers</h2>

<p>Recall the first part of <code class="highlighter-rouge">push()</code>: we load the producer’s head,
and calculate if we have enough room for the incoming data and
if we have, we update the producer’s head to the next position.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">old_prod_head</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span><span class="p">;</span>
    <span class="n">cons_tail</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_tail</span><span class="p">,</span> <span class="n">__ATOMIC_ACQUIRE</span><span class="p">);</span>

    <span class="kt">uint32_t</span> <span class="n">free_entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="n">cons_tail</span> <span class="o">-</span> <span class="n">old_prod_head</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_entries</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="n">free_entries</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_entries</span> <span class="o">||</span> <span class="n">free_entries</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOBUFS</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">new_prod_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span> <span class="o">=</span> <span class="n">new_prod_head</span><span class="p">;</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<p>Consider now what would happen if we have two producers: both will
compete in a race to put what they <em>think</em> that it is the new value of head.</p>

<p>More over the space reserved for both will overlap leading
to a memory corruption.</p>

<figure><figcaption><span>Two producers racing for reserving the same space.</span></figcaption><img src="/book-of-gehn/assets/mpmc-queue/reserve-race-condition.png" /></figure>

<p>What we need is the load, compute and store on <code class="highlighter-rouge">q-&gt;prod_head</code>
as a <em>single atomic operation</em>. This is called <em>read-modify-write</em> operation.</p>

<p>No builtin atomic exists for that but we can built one with a <em>compare and swap</em>
instruction<label for="mn-557e66b2758a8897f20e4426dee57c2e" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-557e66b2758a8897f20e4426dee57c2e" class="margin-toggle" /><span class="marginnote">Or <em>compare and exchange</em> </span>.</p>

<h2 id="move-the-headtail-forward-atomically---cas-loop">Move the head/tail forward atomically - CAS loop</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">old_prod_head</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="n">cons_tail</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_tail</span><span class="p">,</span> <span class="n">__ATOMIC_ACQUIRE</span><span class="p">);</span>

        <span class="kt">uint32_t</span> <span class="n">free_entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="n">cons_tail</span> <span class="o">-</span> <span class="n">old_prod_head</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_entries</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="n">free_entries</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_entries</span> <span class="o">||</span> <span class="n">free_entries</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOBUFS</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">new_prod_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>

        <span class="n">success</span> <span class="o">=</span> <span class="n">__atomic_compare_exchange_n</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span><span class="p">,</span>      <span class="c1">// what we want to update,</span>
                        <span class="o">&amp;</span><span class="n">old_prod_head</span><span class="p">,</span>     <span class="c1">// asumming that still have this value,</span>
                        <span class="n">new_prod_head</span><span class="p">,</span>      <span class="c1">// with this value as the new one.</span>
                        <span class="nb">false</span><span class="p">,</span>
                        <span class="n">__ATOMIC_RELAXED</span><span class="p">,</span>
                        <span class="n">__ATOMIC_RELAXED</span>
                    <span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">);</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<p><label for="mn-a9943ae19dddd108a19afccbbb809e86" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-a9943ae19dddd108a19afccbbb809e86" class="margin-toggle" /><span class="marginnote">Note that I said “it still has the same value”; I did't say “the value
did't change”. For our queue it doesn't matter but for other
structures it is really important and the confusion leads to the
<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA problem</a>
 </span></p>

<p>The idea is to do an atomic read, do all the modifications and checks
that we need and then do an atomic write with the new value
<em>only if</em> the head is <em>still</em> pointing to the same position that we read.</p>

<p>That is what <code class="highlighter-rouge">__atomic_compare_exchange_n</code> is about.</p>

<p>If it is, it means that no other producer moved the head and we can
proceed.</p>

<p><label for="mn-cacb598c79e7dc10a7397be9b1e09e11" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-cacb598c79e7dc10a7397be9b1e09e11" class="margin-toggle" /><span class="marginnote">There is no need to do an explicit atomic load again,
<code class="highlighter-rouge">__atomic_compare_exchange_n</code> will do it for us if it fails. </span></p>

<p>If not, we need to retry again until we succeed.</p>

<p>This loop makes the <code class="highlighter-rouge">push()</code>
to take an unbound number of steps (loop iterations) until
it can proceed. The queue is lock-free but no <em>wait-free</em> anymore.</p>

<h2 id="waiting-for-others">Waiting for others</h2>

<p>Once a producer finished the write it <em>releases</em> it updating
the producer’s tail to the new head.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="c1">// write the data</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">,</span> <span class="n">new_prod_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELEASE</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However we have another race condition here.</p>

<p>It is not about the store of the value, we can use an atomic
store for that; it is about the <em>order</em> of the stores.</p>

<p>Both producers have the correct notion of the next head
thanks to the CAS loop however this is only truth <strong>if</strong>
the first producers updates the tail <strong>before</strong> the second one.</p>

<p>Recall that the producer’s tail is the marker for the consumers
to stop, preventing them to read undefined data.</p>

<p>If the second producer updates the tail there are not guaranties
that the first producer finished her writing by then; she
didn’t <em>released</em> the memory reserved.</p>

<figure><figcaption><span>Two producers racing for marking the data as ready.
<br />
If the producer 2 updates the tail before the producer 1, the
consumers may read that the producer 1 may not had written yet.</span></figcaption><img src="/book-of-gehn/assets/mpmc-queue/ready-race-condition.png" /></figure>

<p>What we need is to enforce an order: all the previous <code class="highlighter-rouge">push()</code> must
complete before a producer update the tail.</p>

<p>We can get this waiting until the tail reaches the old head meaning
that any reserved space for writing (between the tail and the old head)
was used and released.</p>

<p>So the next block reserved begins at the old head/current tail and ends
at the new head.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="c1">// write the data</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">old_prod_head</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="c1">// loop until the tail reaches our original head.</span>
    <span class="c1">// ensuring that no other previous push is still in progress</span>
    <span class="k">while</span> <span class="p">((</span><span class="k">volatile</span> <span class="kt">uint32_t</span><span class="p">)(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old_prod_head</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Tell the CPU that this is busy-loop so he can take a rest</span>
        <span class="n">loki_cpu_relax</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_tail</span><span class="p">,</span> <span class="n">new_prod_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELEASE</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="multi-producer-multi-consumer-queue-final-version">Multi-producer multi-consumer queue (final version)</h2>

<p>The code can be found in <a href="https://github.com/eldipa/loki">the loki library</a>.</p>

<figure class="fullwidth"><img src="/book-of-gehn/assets/mpmc-queue/relativity-quantic-concurrent-programming.png" /><figcaption></figcaption></figure>

<h2 id="future-research-on-the-busy-waits">Future research on the busy waits</h2>

<p>The <code class="highlighter-rouge">push()</code>, and analogously the <code class="highlighter-rouge">pop()</code>, has two busy waits: the
CAS loop for update the head and the wait-for-others for updating
the tail in order.</p>

<p>Both loops have an impact on the parallelism depending of different
factors.</p>

<p>It is expected to have more contention in the CAS loop as the number
of producers increase, especially when the data written is small.</p>

<p>On the other hand, it is expected to have more time wasted on the
wait-for-others loop when the data is larger as this should dominate
the time needed to complete one <code class="highlighter-rouge">push()</code> and therefore preventing
to complete the next ones.</p>

<p>In a future post I will explore this.</p>

<p>More readings:</p>

<ul>
  <li><a href="https://patches.dpdk.org/patch/40489/">preemptive nature of ring algorithm (DPDK)</a></li>
  <li><a href="http://cbloomrants.blogspot.com/2012/06/06-12-12-another-threading-post-index.html">cbloomrants’ posts about threading</a></li>
  <li><a href="http://www.gotw.ca/publications/">H Sutter’s Effective Concurrency seriers</a></li>
  <li><a href="https://preshing.com/">Jeff Preshing’s posts</a></li>
</ul>

<h2 id="other-implementations">Other implementations</h2>

<p>I didn’t have the chance to explore this, but the
<a href="https://software.intel.com/en-us/forums/intel-moderncode-for-parallel-architectures/topic/295836">Thomasson’s MPMC queue</a>
followed another approach based in a linked list.</p>

<p>The documentation says that it has lock free <code class="highlighter-rouge">pop()</code> and wait free
<code class="highlighter-rouge">push()</code>.</p>

<p>The only downside is that requires a double-word CAS instruction.</p>

<h2 id="open-questions">Open questions</h2>

<p>The DPDK’s <a href="http://git.dpdk.org/dpdk/tree/lib/librte_ring/rte_ring_c11_mem.h">ring buffer</a>
adds a <em>fence</em> between the read of the <em>old</em> producer’s head and the read
of the consumer’s tail and I cite:</p>

<blockquote>
  <p>“Ensure the head is read before tail”</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nf">push</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">old_prod_head</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">prod_head</span><span class="p">,</span> <span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="cm">/* Ensure the head is read before tail */</span>
        <span class="n">__atomic_thread_fence</span><span class="p">(</span><span class="n">__ATOMIC_ACQUIRE</span><span class="p">);</span>

        <span class="n">cons_tail</span> <span class="o">=</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">cons_tail</span><span class="p">,</span> <span class="n">__ATOMIC_ACQUIRE</span><span class="p">);</span>

        <span class="kt">uint32_t</span> <span class="n">free_entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="n">cons_tail</span> <span class="o">-</span> <span class="n">old_prod_head</span><span class="p">);</span>

        <span class="cm">/* rest of the CAS loop */</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">);</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<p>The <em>thread fence</em> synchronize with the atomic ensuring that
the head stored by one producer is visible by the load of another.</p>

<p>Is it possible for a producer to load a head <em>too</em> old? By the moment
of the load another producer had already stored a new value but it is still
not visible by the former.</p>

<p>If that is possible the former producer will compute an incorrect <code class="highlighter-rouge">free_entries</code>.</p>

<p>What about the CAS instruction? If the producer didn’t see the updated value
by the time it does the CAS instruction, it will be setting the <em>wrong</em> head
value just as if the CAS loop wasn’t there.</p>

<p>Am I missing something? – Probably.</p>

<h2 id="references">References</h2>

<p>Kip Macy implemented a <a href="https://svnweb.freebsd.org/base/release/8.0.0/sys/sys/buf_ring.h?revision=199625&amp;amp">buffer ring</a>
for FreeBSD. It was the base foundation
for DPDK’s <a href="http://git.dpdk.org/dpdk/tree/lib/librte_ring/rte_ring_c11_mem.h">rte_ring</a>.</p>

<p>Also <a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">GCC Atomics, gcc.gnu.org</a>
and my previous post
<a href="/book-of-gehn/articles/2020/03/22/Lock-Free-Queue-Part-I.html">lock-free single-producer single-consumer queue</a>.</p>

<p>Also:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=A8eCGOqgvH4">C++ and Beyond 2012: Herb Sutter - Atomic Weapons - Part 1</a></li>
  <li><a href="https://www.youtube.com/watch?v=KeLBd2EJLOU">C++ and Beyond 2012: Herb Sutter - Atomic Weapons - Part 2</a></li>
</ul>

<p>References at March 2020.</p>




    </article>
    <span class="print-footer">Lock Free Queue - Part II - April 28, 2020 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
