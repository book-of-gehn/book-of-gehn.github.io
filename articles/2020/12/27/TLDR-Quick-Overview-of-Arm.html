<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>TL;DR Quick Overview of Arm</title>
  <meta name="description" content="Speed-reading ofWhirlwind Tour of ARM Assembly.">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2020/12/27/TLDR-Quick-Overview-of-Arm.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>TL;DR Quick Overview of Arm</h1>
<p class="subtitle">December 27, 2020</p>

<p>Speed-reading of
<a href="https://www.coranac.com/tonc/text/asm.htm">Whirlwind Tour of ARM Assembly</a>.<!--more--></p>

<h1 id="the-arm-instruction-set">The Arm instruction set</h1>

<p>Arm is a Reduced Instruction Set Computer (RISC) which have a small set
of instructions of fixed size in contrast with the Complex Instruction
Set Computer (CISC).</p>

<p>In Arm the instructions are of 32 bits and the Thumb version has 16 and
32 bits instructions.</p>

<p>ARMv3 to ARMv7 versions has 32 bits addresses, previous version has 26
bits and ARMv8 introduced the 64 bits addresses.</p>

<h3 id="almost-everything-is-conditional">Almost everything is conditional</h3>

<p>Instructions can be executed conditionally. This avoids explicit jumps
which are slower and the overall code size is smaller.</p>

<p>Use this for small snippets and fallback to traditional branches/jumps
when the code is too large.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">; r2 = max(r0, r1), traditional impl with branches</span>
    <span class="k">cmp</span>     <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
    <span class="n">blt</span>     <span class="p">.</span><span class="n">Lbmax</span>      <span class="c">; go to Lbmax if r0 &lt; r1</span>
    <span class="k">mov</span>     <span class="n">r2</span><span class="p">,</span> <span class="n">r0</span>      <span class="c">; r0 is higher ==&gt; r0 &gt; r1</span>
    <span class="n">b</span>       <span class="p">.</span><span class="n">Lrest</span>      <span class="c">; finish</span>
<span class="p">.</span><span class="n">Lbmax</span><span class="o">:</span>
    <span class="k">mov</span>     <span class="n">r2</span><span class="p">,</span> <span class="n">r1</span>      <span class="c">; r1 is higher</span>
<span class="p">.</span><span class="n">Lrest</span><span class="o">:</span>
    <span class="p">...</span>                 <span class="c">;  rest of code</span>

<span class="c">; r2 = max(r0, r1), with conditionals moves</span>
    <span class="k">cmp</span>     <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
    <span class="n">movge</span>   <span class="n">r2</span><span class="p">,</span> <span class="n">r0</span>      <span class="c">;  move if r0 &gt;= r1 (r0 is higher)</span>
    <span class="n">movlt</span>   <span class="n">r2</span><span class="p">,</span> <span class="n">r1</span>      <span class="c">;  move if r0 &lt; r1  (r1 is higher)</span>
    <span class="p">...</span>                 <span class="c">;  rest of code</span>
</code></pre></div></div>

<blockquote>
  <p>Example took from
<a href="https://www.coranac.com/tonc/text/asm.htm">Whirlwind Tour of Arm Assembly</a></p>
</blockquote>

<p>Other instructions are also conditional. Even the set of the CPSR
flags is conditional: <code class="highlighter-rouge">sub</code> does not set the status flags while <code class="highlighter-rouge">subs</code>
it does.</p>

<h3 id="immediate-values-and-the-second-operand-shift">Immediate values and the second operand shift</h3>

<p>Some instructions allow the second operand to be shifted/rotated in the
same instruction.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">add</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r1</span>          <span class="c">;  r0 = r1 + r1</span>
    <span class="k">add</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="k">lsl</span> <span class="err">#</span><span class="mi">4</span>  <span class="c">;  r0 = r1 + (r1 &lt;&lt; 4)</span>
    <span class="k">add</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="k">lsl</span> <span class="n">r2</span>  <span class="c">;  r0 = r1 + (r1 &lt;&lt; r2)</span>
</code></pre></div></div>

<p>Five shift/rotation exist, both as part of an instruction like above
and as independent instructions as well.</p>

<blockquote>
  <p>The immediate value for shifts is limited to 31.</p>
</blockquote>

<p>Logical shift left <code class="highlighter-rouge">lsl</code>, logical shift right <code class="highlighter-rouge">lsr</code>, arithmetic shift
right <code class="highlighter-rouge">asr</code>, rotate right <code class="highlighter-rouge">ror</code> and rotate right with extend <code class="highlighter-rouge">rrx</code> (the
32 bits register is extended on the left with the <em>carry</em> bit: the LSB
is rotated to the carry bit and the carry bit is shifted to the right
into the MSB of the register)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          10000110
           \\\\\\\\
           ||||||| \
           vvvvvvv  \
          01000011   -&gt; 0   (logical shift right)
          11000011   -&gt; 0   (arithmetic shift right)

          10000110
           \\\\\\\\
           ||||||| \
           vvvvvvv  \
          01000011   |      (rotate shift right)
          ^---------/

   C=0    10000110
      \    \\\\\\\\
       \--\||||||| \
          vvvvvvvv  \
   C=0    01000011   |     (rotate right extended)
     ^---------------/
</code></pre></div></div>

<p>Having all these nice features in one instruction (shift, conditional,
flag set) come with a cost: less room for immediate values.</p>

<p>In Thumb-2 and ARMv6 and above exists <code class="highlighter-rouge">mov rd, #&lt;imm16&gt;</code> to set a 16
bits number in a register without the possibility of using any of those
fancy features. It is a plain move.</p>

<p>But that’s the exception to the rule. Most of the instructions
including fancy moves only allow 8 bits immediate values.</p>

<p>Like</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">movs</span> <span class="n">r0</span><span class="p">,</span> <span class="err">#</span><span class="o">&lt;</span><span class="n">imm8</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">lsl</span> <span class="err">#</span><span class="mi">4</span>    <span class="c">;  r0 = imm8 &lt;&lt; 4, update condition flags</span>
</code></pre></div></div>

<p>Larger than 255 values in <code class="highlighter-rouge">#&lt;imm8&gt;</code> are possible because the instruction
has 12 bits to store them. Why not just <code class="highlighter-rouge">#&lt;imm12&gt;</code> then?</p>

<p>The 4 extra bits are used to rotate to the right the <code class="highlighter-rouge">#&lt;imm8&gt;</code> value by
<em>twice</em> the number encoded in those 4 bits.</p>

<p>In other words, the final value is <code class="highlighter-rouge">n8 ror (2*r4)</code>: the 8 bits encoded
number rotated by twice the 4 bits encoded.</p>

<p>This allows to set immediate values larger than 12 bits but loosing the
possibility to encode some numbers. If you try to set one of those you
will get a <em>invalid constant</em> error.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">mov</span> <span class="n">r2</span><span class="p">,</span> <span class="mi">128000</span>  <span class="c">;   r2 = 0x1f400</span>
    <span class="k">mov</span> <span class="n">r2</span><span class="p">,</span> <span class="mi">127999</span>  <span class="c">;   Invalid operand (KS_ERR_ASM_INVALIDOPERAND)</span>
</code></pre></div></div>

<p>More instructions are needed to compute an arbitrary 32 bits number or a
load.</p>

<blockquote>
  <p>Note: a 32 bit number can be set in two instructions: set the 16 lower
bits with <code class="highlighter-rouge">mov rd, #&lt;imm16&gt;</code> and set the 16 upper bits with <em>move
top</em>, <code class="highlighter-rouge">movt rd, #&lt;imm16&gt;</code></p>
</blockquote>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">mov</span> <span class="n">r2</span><span class="p">,</span> <span class="mh">0xccdd</span>      <span class="c">;   r2 = 0x0000ccdd</span>
    <span class="n">movt</span> <span class="n">r2</span><span class="p">,</span> <span class="mh">0xaabb</span>     <span class="c">;   r2 = 0xaabbccdd</span>
</code></pre></div></div>

<h2 id="registers">Registers</h2>

<p><code class="highlighter-rouge">r0</code> to <code class="highlighter-rouge">r3</code> are <em>scratch</em> registers: they are not preserved cross calls
and it is caller’s responsibility to preserve them if needed.</p>

<p><code class="highlighter-rouge">r4</code> to <code class="highlighter-rouge">r11</code> are <em>variable</em> registers: they must be preserved cross
calls and it is callee’s responsibility to preserve them if needed.</p>

<p><code class="highlighter-rouge">r9</code> may play a different roll (platform dependent, known also as
<em>static base</em> register or <code class="highlighter-rouge">sb</code>) and <code class="highlighter-rouge">r11</code>
may play the roll of <code class="highlighter-rouge">fp</code> so both may not be free for arbitrary usage.</p>

<p>The <code class="highlighter-rouge">bl</code> instruction saves the next instruction (the <em>return address</em>)
in the <em>link</em> <code class="highlighter-rouge">lr</code> register (<code class="highlighter-rouge">r14</code>) and set the destination address
in the <em>program counter</em> <code class="highlighter-rouge">pc</code> register (<code class="highlighter-rouge">r15</code>).</p>

<p>For “long jumps” and inter-operability, the <em>intra-procedure-call</em>
registry <code class="highlighter-rouge">ip</code> (<code class="highlighter-rouge">r12</code>) is used.</p>

<p><code class="highlighter-rouge">r13</code> is the <em>stack pointer</em> <code class="highlighter-rouge">sp</code>.</p>

<p>Take a look at the
<a href="https://developer.arm.com/documentation/ihi0042/latest/">Procedure Call Standard for the Arm Architecture</a></p>

<h2 id="data-instructions">Data instructions</h2>

<p>The arithmetic and logical instructions fall in this category; they
manipulate only on registers, never on memory.</p>

<p>The destination and the first operand are registers while the second can
be a register, and immediate value or a register shifted by another
register or immediate value.</p>

<p>They can be conditionally executed and conditionally set the status
flags.</p>

<p>The
<a href="https://documentation-service.arm.com/static/5ed66080ca06a95ce53f932d?token=">ARM and Thumb-2 Instruction Set Quick Reference Card</a>
is your friend!</p>

<p>There are no division instructions except on ARMv7-R and ARMv7-M and multiplication
operations are more special.</p>

<p>Because the registers are of 32 bits, the result of a multiplication
cannot fit there: we need 64 bits!</p>

<p>There are two sets of multiplications: the one that stores the result in
a 32 bits register (<code class="highlighter-rouge">mul rd, rm, rs</code>) and the one that stores it in two
registers (<code class="highlighter-rouge">umull rdlo, rdhi, rm rs</code>) – the extra <code class="highlighter-rouge">l</code> means <code class="highlighter-rouge">long</code>.</p>

<h2 id="memory-instructions-load-and-store">Memory instructions: load and store</h2>

<p>Loads and stores are quite similar: they can operate (load/store)
on 32 bits words, half-words (<code class="highlighter-rouge">h</code>) and bytes (<code class="highlighter-rouge">b</code>), zero extended or
signed extended (<code class="highlighter-rouge">s</code>, <code class="highlighter-rouge">sh</code> and <code class="highlighter-rouge">sb</code> respectively).</p>

<blockquote>
  <p>Note: <code class="highlighter-rouge">sb</code> and <code class="highlighter-rouge">sh</code> prefixes are not supported for stores.</p>
</blockquote>

<h3 id="indexing">Indexing</h3>

<p>In <code class="highlighter-rouge">ldr rd, [rn]</code> or <code class="highlighter-rouge">str rd, [rn]</code>, the <code class="highlighter-rouge">[ ]</code> denotes dereferencing
and the <code class="highlighter-rouge">rn</code> register is the <em>base register</em>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="p">[sp]</span>  <span class="c">; r0 = stack top</span>
</code></pre></div></div>

<p>This is the <em>register indirect addressing</em>.</p>

<p>An offset can be added to the base register, useful to iterate over an
array like <code class="highlighter-rouge">ldr rd, [rn, rm]</code>, <code class="highlighter-rouge">ldr rd, [rn, #4]</code>
or even <code class="highlighter-rouge">ldr rd, [rn, rm, lsl #4]</code>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="p">[sp]</span>                <span class="c">; r0 = stack top</span>
    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="err">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="mi">4</span><span class="err">]</span>            <span class="c">; r0 = elem below the top</span>
    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="err">[</span><span class="n">sp</span><span class="p">,</span> <span class="n">r3</span><span class="err">]</span>            <span class="c">; if r3 == 4, same above (sp + 4)</span>
    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="err">[</span><span class="n">sp</span><span class="p">,</span> <span class="n">r3</span><span class="p">,</span> <span class="k">lsl</span> <span class="err">#</span><span class="mi">2</span><span class="err">]</span>    <span class="c">; if r3 == 2, same above (sp + (1 &lt;&lt; 2))</span>
</code></pre></div></div>

<p>This is known as <em>pre-index addressing</em>.</p>

<p>Note the use of squares in <code class="highlighter-rouge">ldr rd, [rn, rm, lsl #4]</code>, the instruction
<code class="highlighter-rouge">ldr rd, [rn], rm, lsl #4</code> is a pre-index addressing <em>with post
write-back</em>: the base address is updated with the final value <em>after</em>
the load completed.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="p">[sp],</span> <span class="err">#</span><span class="mi">4</span>     <span class="c">; r0 = stack top, sp move 4 down (aka "pop")</span>
    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="p">[sp],</span> <span class="err">#</span><span class="mi">4</span>     <span class="c">; r0 = next stack top, sp move 4 down (aka "pop")</span>
</code></pre></div></div>

<p>A <em>pre write-back</em> variant exists: <code class="highlighter-rouge">ldr rd, [rn, rm, lsl #4]!</code>.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="err">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="mi">4</span><span class="err">]!</span>    <span class="c">; r0 = sp move 4 down then load (top was skipped)</span>
</code></pre></div></div>

<blockquote>
  <p>Note: <em>pre write-back</em> makes more sense for stores (aka pushes)
and <em>post write-back</em> for loads (aka pops)</p>
</blockquote>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">; swap r0, r1 using the stack, really slow!</span>
    <span class="k">str</span> <span class="n">r0</span><span class="p">,</span> <span class="err">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">4</span><span class="err">]!</span>    <span class="c">; r0 = sp move 4 up then store (aka push)</span>
    <span class="k">str</span> <span class="n">r1</span><span class="p">,</span> <span class="err">[</span><span class="n">sp</span><span class="p">,</span> <span class="err">#</span><span class="o">-</span><span class="mi">4</span><span class="err">]!</span>    <span class="c">; r1 = sp move 4 up then store (aka push)</span>
    <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="p">[sp],</span> <span class="err">#</span><span class="mi">4</span>      <span class="c">; r0 = stack top, sp move 4 down (aka "pop")</span>
    <span class="n">ldr</span> <span class="n">r1</span><span class="p">,</span> <span class="p">[sp],</span> <span class="err">#</span><span class="mi">4</span>      <span class="c">; r1 = stack top, sp move 4 down (aka "pop")</span>
</code></pre></div></div>

<p><em>PC-relative addressing</em> allows to load a memory which address is an
offset of the program counter: <code class="highlighter-rouge">ldr rd, &lt;label&gt;</code>. This works only for
loads; useful to load numbers that cannot fit in an <code class="highlighter-rouge">imm8</code>.</p>

<blockquote>
  <p>Not all the combinations of sizes and addressing are possible. Check
the data sheet.</p>
</blockquote>

<h3 id="bulk-loadstore">Bulk load/store</h3>

<p>Several registers can be loaded or stored with a single <em>load multiple</em>
(<code class="highlighter-rouge">ldm</code>) and <em>store multiple</em> (<code class="highlighter-rouge">stm</code>) instructions.</p>

<p>They have a base address, a <em>set</em> of registers and an <em>indexing affix</em>
which controls how to “iterate the array/memory”.</p>

<p>Four indexing exists: increment of the base address after/before accessing
the memory (<code class="highlighter-rouge">ia</code>/<code class="highlighter-rouge">ib</code>) and decrement of the base address after/before
(<code class="highlighter-rouge">da</code>/<code class="highlighter-rouge">db</code>).</p>

<p><code class="highlighter-rouge">ia</code> is the default.</p>

<p>In short:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c">;              r4, r5, r6, r7</span>
    <span class="n">ldmia</span>   <span class="n">r0</span><span class="p">,</span> <span class="err">{</span><span class="n">r4</span><span class="o">-</span><span class="n">r7</span><span class="err">}</span>     <span class="c">;  *src++    :  0,  1,  2,  3</span>
    <span class="n">ldmib</span>   <span class="n">r0</span><span class="p">,</span> <span class="err">{</span><span class="n">r4</span><span class="o">-</span><span class="n">r7</span><span class="err">}</span>     <span class="c">;  *++src    :  1,  2,  3,  4</span>
    <span class="n">ldmda</span>   <span class="n">r0</span><span class="p">,</span> <span class="err">{</span><span class="n">r4</span><span class="o">-</span><span class="n">r7</span><span class="err">}</span>     <span class="c">;  *src--    : -3, -2, -1,  0</span>
    <span class="n">ldmdb</span>   <span class="n">r0</span><span class="p">,</span> <span class="err">{</span><span class="n">r4</span><span class="o">-</span><span class="n">r7</span><span class="err">}</span>     <span class="c">;  *--src    : -4, -3, -2, -1</span>
</code></pre></div></div>

<p>Note the it is a <em>set</em> of registers, <strong>not a list</strong> so the order
is not important. The registers are loaded/stored by their index from
<code class="highlighter-rouge">r0</code> to <code class="highlighter-rouge">r15</code>.</p>

<p>For loads the registers are loaded from memory into the registers
in the natural order: from <code class="highlighter-rouge">r0</code> to <code class="highlighter-rouge">r15</code>. For stores, the registers
are dump into memory in the reverse order.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="o">&lt;------</span> <span class="n">store</span> <span class="n">direction</span>    <span class="o">&lt;------</span> <span class="n">stack</span> <span class="n">grows</span>
    <span class="n">stmdb</span> <span class="n">sp</span><span class="err">!</span><span class="p">,</span>  <span class="err">{</span><span class="n">r0</span><span class="p">,</span><span class="n">r1</span><span class="err">}</span>    <span class="c">; stack top -&gt; [r0  r1]</span>
    <span class="n">ldmia</span> <span class="n">sp</span><span class="err">!</span><span class="p">,</span>  <span class="err">{</span><span class="n">r2</span><span class="p">,</span><span class="n">r3</span><span class="err">}</span>    <span class="c">; r2 = r0; r3 = r1</span>
        <span class="n">load</span> <span class="n">direction</span> <span class="o">------&gt;</span>     <span class="n">stack</span> <span class="n">shrinks</span> <span class="o">----&gt;</span>
</code></pre></div></div>

<p>The additional <code class="highlighter-rouge">!</code> symbol means update the base register <em>before</em> the
load or store but it doesn’t change how the load/store works.</p>

<p>The data sheet says that <code class="highlighter-rouge">push</code> and <code class="highlighter-rouge">pop</code> have the canonical form of
<code class="highlighter-rouge">stmdb sp!, {regs}</code> and <code class="highlighter-rouge">ldmia sp!, {regs}</code> respectively.</p>

<blockquote>
  <p>Note that <code class="highlighter-rouge">sp</code> points to the last value of the stack and <code class="highlighter-rouge">stmdb</code>
decrements the base address (<code class="highlighter-rouge">sp</code>) before doing the store in a <code class="highlighter-rouge">push</code>
while <code class="highlighter-rouge">ldmia</code> increments after the load in a <code class="highlighter-rouge">pop</code>.</p>

  <p>In both cases the <code class="highlighter-rouge">sp</code> is updated <em>before</em> (<em>pre write-back</em>) regardless
of <code class="highlighter-rouge">db</code>/<code class="highlighter-rouge">ia</code>.</p>

  <p>Note also that the stack grows decrementing the addresses and shrinks
incrementing the addresses.</p>
</blockquote>

<h3 id="alignment">Alignment</h3>

<p>The assembler can do it for you: <code class="highlighter-rouge">.align n</code> aligns the code or data to 2^n
bytes.</p>

<h3 id="endianess">Endianess</h3>

<p>Since version 3, Arm is bi-endian. The instructions are in little
endian but the data access can be little or big endian controlled by the
<code class="highlighter-rouge">E</code> flag of CPSR.</p>

<h2 id="conditionals-and-branches">Conditionals and branches</h2>

<p>Three branches: <em>branch</em> (<code class="highlighter-rouge">b</code>) for <code class="highlighter-rouge">if</code> and <code class="highlighter-rouge">while</code> constructs,
<em>branch with link</em> (<code class="highlighter-rouge">bl</code>) for function call and <em>branch with exchange</em>
(<code class="highlighter-rouge">bx</code>) for returning from a call or to switch between Arm and Thumb
modes.</p>

<p>The first two receive a label while the last one operates with a
register.</p>

<p>More branches exist including <em>branch with change to Jazelle</em> (<code class="highlighter-rouge">bxj</code>)
which can switch to a special mode that
<a href="https://en.wikipedia.org/wiki/Jazelle">executes Java bytecode</a> if
supported.</p>

<p>Due instruction size constrains, labels cannot be in arbitrary
positions. The <code class="highlighter-rouge">b</code> and <code class="highlighter-rouge">bl</code> requires the destination addresses to be in
a range relative to <code class="highlighter-rouge">PC</code> of [-32MB;+32MB].</p>

<p>The range shrinks for other flavours of Arm to [-16MB;+16MB] and to
[-252,256].</p>

<p>The branches can, as other instructions, be conditional executed. So
<code class="highlighter-rouge">bne</code> stands for branch if not equals.</p>

<p>Two registers have the flags that controls the conditional execution:
the <em>Current Program Status Register</em>
(CPSR) and the <em>Saved Program Status Register</em> (SPSR), used during the
interrupt handling.</p>

<p>The flags are set by special instructions like <em>compare</em> (<code class="highlighter-rouge">cmp</code>) or by
data manipulation instructions if the affix <code class="highlighter-rouge">s</code> is added like in <code class="highlighter-rouge">adds</code>.</p>

<p>Not all the data manipulation instructions alter all the flags. For
example the <em>overflow</em> flag (<code class="highlighter-rouge">v</code>) is set by arithmetic operations and
not by bit operations.</p>

<h3 id="branching-and-condition-codes">Branching and condition codes</h3>

<p>Current Program Status Register (CPSR):</p>

<ul>
  <li>Z: is zero?</li>
  <li>N: is negative? (is MSB set?)</li>
  <li>C: is carry bit set? (in a 32 bit register with bits numbered from 0
(LSB) to 31 (MSB), is the 32 bit set?)</li>
  <li>V: was an arithmetic overflow? (like given a&gt;0 &amp; b&gt;0 and then a+b &lt; 0)</li>
  <li>E: are we in big endian mode (E==1) or in little endian (E==0)?</li>
</ul>

<h2 id="symbols">Symbols</h2>

<p>Global labels are defined with <code class="highlighter-rouge">.global label</code> while local labels
are just <code class="highlighter-rouge">.label</code> (conventionally they begin with <code class="highlighter-rouge">L</code> to denote local
but it is optional)</p>

<p><code class="highlighter-rouge">.code n</code> declares the type of code: Arm (<code class="highlighter-rouge">n</code> is 32) or Thumb (<code class="highlighter-rouge">n</code> is
16). Alternative there are <code class="highlighter-rouge">.arm</code> and <code class="highlighter-rouge">.thumb</code> directives that do the
same.</p>

<p>These affect all the code below until another directive change the
setting.</p>

<p><code class="highlighter-rouge">.thumb_func</code> on the other side affects only to the next symbol and it
is required for <em>interworking</em> Thumb functions.</p>

<p>Alignment of code and data can be set by <code class="highlighter-rouge">.aling n</code> and <code class="highlighter-rouge">.baling m</code>
where the former aligns to <code class="highlighter-rouge">2^n</code> bytes and the latter to <code class="highlighter-rouge">m</code> bytes.</p>

<p>They apply to the next instruction/data, they are not global.</p>

<p><code class="highlighter-rouge">.type funcname %function</code> declares a function.</p>

<h2 id="definition-of-variables">Definition of variables</h2>

<p><code class="highlighter-rouge">.byte</code>, <code class="highlighter-rouge">.hword</code> and <code class="highlighter-rouge">.word</code> define data, array of items of 1, 2 and 4
bytes each.</p>

<p>This is handy way to define <em>“variables”</em> in the code:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">.</span><span class="n">align</span> <span class="mi">2</span>            <span class="c">;  mantain the alignment, always!</span>
<span class="n">one_word</span><span class="o">:</span>
    <span class="p">.</span><span class="n">word</span> <span class="mh">0x41424344</span>
<span class="n">one_array_u16</span><span class="o">:</span>
    <span class="p">.</span><span class="n">hword</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span>
<span class="n">hello</span><span class="o">:</span>
    <span class="p">.</span><span class="n">string</span> <span class="s">"hello"</span><span class="p">,</span> <span class="s">"hello world!"</span>   <span class="c">;  array of NULL-terminated strings</span>
</code></pre></div></div>

<h2 id="sections">Sections</h2>

<p>These are <code class="highlighter-rouge">.data</code> (read-write non-zero initialized data) and <code class="highlighter-rouge">.bss</code>
(read-write zero initialized data).</p>

<p>Other sections exist as well and they are denoted with <code class="highlighter-rouge">.section</code> like
<code class="highlighter-rouge">.section .rodata</code> for read-only data.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">.</span><span class="n">data</span>
    <span class="p">.</span><span class="n">align</span> <span class="mi">2</span>
<span class="n">magic</span><span class="o">:</span>
    <span class="p">.</span><span class="n">word</span> <span class="mi">42</span>

    <span class="p">.</span><span class="n">bss</span>
<span class="n">counter</span><span class="o">:</span>
    <span class="p">.</span><span class="n">space</span> <span class="mi">4</span>
</code></pre></div></div>

<p>Code section is denoted by <code class="highlighter-rouge">.text</code></p>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://www.coranac.com/tonc/text/asm.htm">Whirlwind Tour of ARM Assembly</a>.</li>
  <li><a href="https://documentation-service.arm.com/static/5ed66080ca06a95ce53f932d?token=">ARM and Thumb-2 Instruction Set Quick Reference Card</a></li>
  <li><a href="https://developer.arm.com/documentation/ihi0042/latest/">Procedure Call Standard for the Arm Architecture</a></li>
</ul>



    </article>
    <span class="print-footer">TL;DR Quick Overview of Arm - December 27, 2020 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
