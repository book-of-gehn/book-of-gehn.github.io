<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>TL;DR Quick Overview of Arm</title>
  <meta name="description" content="TL;DR Quick Overview of Arm">

  <link href='/css/load-lato-fonts.min.css' rel='stylesheet' type='text/css'>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      root: "/js/MathJax-2.7.7",
      extensions: ["tex2jax.js"],
      jax: ["input/TeX","output/HTML-CSS"],
      tex2jax: {inlineMath: [["\\(","\\)"]]},
      TeX: {
        Macros: {
          
        }
      }
    });
  </script>
  <!-- <script src='/js/MathJax-2.7.7/MathJax.js' async></script> -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js' async></script>

  <script src="/js/jquery-3.6.0.min.js"></script>

  <script src='/js/underscore-1.9.1.min.js' ></script>

  <script src='/js/d3-7.4.2.min.js'></script>

  <script src='/js/venn/venn-0.2.14.min.js'></script>
  <script src='/js/venn/helper.min.js'></script>

  <script src='/js/fix_syntax_highlight.min.js'></script>
  <link rel="stylesheet" type="text/css" href="/css/tufte.min.css">
  <link rel="stylesheet" type="text/css" href="/css/latex.min.css">

  <link rel="canonical" href="https://book-of-gehn.github.io/articles/2020/12/27/TLDR-Quick-Overview-of-Arm.html">

  <link rel="stylesheet" type="text/css" href="/css/font-awesome-5.min.css">

  <script src='/js/lunr-2.3.9.min.js'></script>
  <script src='/js/search_index.js'></script>
  <script src='/js/search.min.js'></script>
</head>
<body>
<header>
                <hgroup class="header-group">
        <h1 class="header-title"><a href="/">The Book of Gehn</a></h1>
                </hgroup>
                <ul class="header-list">
                    <li><a href="https://byexamples.github.io">byexample</a></li>
                    <li><a href="https://bisturi.github.io">bisturi</a></li>
                    <li>
                        <a class="raw_link" href="/feed.xml"><img height="16px" width="16px" src="/img/rss-32px.png" /></a>
                        <a class="raw_link" href="https://github.com/eldipa"><img height="16px" width="16px" src="/img/github.png" /></a>
                    </li>
                </ul>
        
        

    

    <nav class="group">
            <form id="blog-search-form">
                <input type="search" placeholder="+must -not *fuzzy*"></input>
                <span class="query-error"></span>
                <span class="controls">
                    <button type="submit">Filter</button>
                    <button style="display: none;" id="reset_search" type="reset">Clear</button>
                </span>
            </form>
    </nav>

    <div style="display: none;" id="search_error"></div>
    <article style="display: none;" class="group" id="search_results">
    </article>
</header>
<article class="group">
<h1>
TL;DR Quick Overview of Arm
</h1>
<p class="subtitle">
December 27, 2020
</p>
<p>Speed-reading of <a href="https://www.coranac.com/tonc/text/asm.htm">Whirlwind Tour of ARM Assembly</a>.<!--more--></p>
<h1 id="the-arm-instruction-set">The Arm instruction set</h1>
<p>Arm is a Reduced Instruction Set Computer (RISC) which have a small set of instructions of fixed size in contrast with the Complex Instruction Set Computer (CISC).</p>
<p>In Arm the instructions are of 32 bits and the Thumb version has 16 and 32 bits instructions.</p>
<p>ARMv3 to ARMv7 versions has 32 bits addresses, previous version has 26 bits and ARMv8 introduced the 64 bits addresses.</p>
<h3 id="almost-everything-is-conditional">Almost everything is conditional</h3>
<p>Instructions can be executed conditionally. This avoids explicit jumps which are slower and the overall code size is smaller.</p>
<p>Use this for small snippets and fallback to traditional branches/jumps when the code is too large.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="c1">; r2 = max(r0, r1), traditional impl with branches</span><span class="w"></span>
<span class="w">    </span><span class="nf">cmp</span><span class="w">     </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="w"></span>
<span class="w">    </span><span class="nf">blt</span><span class="w">     </span><span class="nv">.Lbmax</span><span class="w">      </span><span class="c1">; go to Lbmax if r0 &lt; r1</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w">     </span><span class="nb">r2</span><span class="p">,</span><span class="w"> </span><span class="nb">r0</span><span class="w">      </span><span class="c1">; r0 is higher ==&gt; r0 &gt; r1</span><span class="w"></span>
<span class="w">    </span><span class="nf">b</span><span class="w">       </span><span class="nv">.Lrest</span><span class="w">      </span><span class="c1">; finish</span><span class="w"></span>
<span class="nl">.Lbmax:</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w">     </span><span class="nb">r2</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="w">      </span><span class="c1">; r1 is higher</span><span class="w"></span>
<span class="nl">.Lrest:</span><span class="w"></span>
<span class="w">    </span><span class="nf">...</span><span class="w">                 </span><span class="c1">;  rest of code</span><span class="w"></span>

<span class="c1">; r2 = max(r0, r1), with conditionals moves</span><span class="w"></span>
<span class="w">    </span><span class="nf">cmp</span><span class="w">     </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="w"></span>
<span class="w">    </span><span class="nf">movge</span><span class="w">   </span><span class="nb">r2</span><span class="p">,</span><span class="w"> </span><span class="nb">r0</span><span class="w">      </span><span class="c1">;  move if r0 &gt;= r1 (r0 is higher)</span><span class="w"></span>
<span class="w">    </span><span class="nf">movlt</span><span class="w">   </span><span class="nb">r2</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="w">      </span><span class="c1">;  move if r0 &lt; r1  (r1 is higher)</span><span class="w"></span>
<span class="w">    </span><span class="nf">...</span><span class="w">                 </span><span class="c1">;  rest of code</span><span class="w"></span>
</code></pre></div>

<blockquote>
<p>Example took from <a href="https://www.coranac.com/tonc/text/asm.htm">Whirlwind Tour of Arm Assembly</a></p>
</blockquote>
<p>Other instructions are also conditional. Even the set of the CPSR flags is conditional: <code><span class="highlight-candombe-inline"><span class="nf">sub</span><span class="w"></span></span></code> does not set the status flags while <code><span class="highlight-candombe-inline"><span class="nf">subs</span><span class="w"></span></span></code> it does.</p>
<h3 id="immediate-values-and-the-second-operand-shift">Immediate values and the second operand shift</h3>
<p>Some instructions allow the second operand to be shifted/rotated in the same instruction.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="w">          </span><span class="c1">;  r0 = r1 + r1</span><span class="w"></span>
<span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="p">,</span><span class="w"> </span><span class="nv">lsl</span><span class="w"> </span><span class="c1">#4  ;  r0 = r1 + (r1 &lt;&lt; 4)</span><span class="w"></span>
<span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="p">,</span><span class="w"> </span><span class="nb">r1</span><span class="p">,</span><span class="w"> </span><span class="nv">lsl</span><span class="w"> </span><span class="nb">r2</span><span class="w">  </span><span class="c1">;  r0 = r1 + (r1 &lt;&lt; r2)</span><span class="w"></span>
</code></pre></div>

<p>Five shift/rotation exist, both as part of an instruction like above and as independent instructions as well.</p>
<blockquote>
<p>The immediate value for shifts is limited to 31.</p>
</blockquote>
<p>Logical shift left <code><span class="highlight-candombe-inline"><span class="nf">lsl</span><span class="w"></span></span></code>, logical shift right <code><span class="highlight-candombe-inline"><span class="nf">lsr</span><span class="w"></span></span></code>, arithmetic shift right <code><span class="highlight-candombe-inline"><span class="nf">asr</span><span class="w"></span></span></code>, rotate right <code><span class="highlight-candombe-inline"><span class="nf">ror</span><span class="w"></span></span></code> and rotate right with extend <code><span class="highlight-candombe-inline"><span class="nf">rrx</span><span class="w"></span></span></code> (the 32 bits register is extended on the left with the <em>carry</em> bit: the LSB is rotated to the carry bit and the carry bit is shifted to the right into the MSB of the register)</p>
<pre><code>          10000110
           \\\\\\\\
           ||||||| \
           vvvvvvv  \
          01000011   -&gt; 0   (logical shift right)
          11000011   -&gt; 0   (arithmetic shift right)

          10000110
           \\\\\\\\
           ||||||| \
           vvvvvvv  \
          01000011   |      (rotate shift right)
          ^---------/

   C=0    10000110
      \    \\\\\\\\
       \--\||||||| \
          vvvvvvvv  \
   C=0    01000011   |     (rotate right extended)
     ^---------------/</code></pre>
<p>Having all these nice features in one instruction (shift, conditional, flag set) come with a cost: less room for immediate values.</p>
<p>In Thumb-2 and ARMv6 and above exists <code><span class="highlight-candombe-inline"><span class="nf">mov</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="c1">#&lt;imm16&gt;</span><span class="w"></span></span></code> to set a 16 bits number in a register without the possibility of using any of those fancy features. It is a plain move.</p>
<p>But that’s the exception to the rule. Most of the instructions including fancy moves only allow 8 bits immediate values.</p>
<p>Like</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">movs</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="c1">#&lt;imm8&gt;, lsl #4    ;  r0 = imm8 &lt;&lt; 4, update condition flags</span><span class="w"></span>
</code></pre></div>

<p>Larger than 255 values in <code><span class="highlight-candombe-inline"><span class="c1">#&lt;imm8&gt;</span><span class="w"></span></span></code> are possible because the instruction has 12 bits to store them. Why not just <code><span class="highlight-candombe-inline"><span class="c1">#&lt;imm12&gt;</span><span class="w"></span></span></code> then?</p>
<p>The 4 extra bits are used to rotate to the right the <code><span class="highlight-candombe-inline"><span class="c1">#&lt;imm8&gt;</span><span class="w"></span></span></code> value by <em>twice</em> the number encoded in those 4 bits.</p>
<p>In other words, the final value is <code><span class="highlight-candombe-inline"><span class="nf">n8</span><span class="w"> </span><span class="nv">ror</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">r4</span><span class="p">)</span><span class="w"></span></span></code>: the 8 bits encoded number rotated by twice the 4 bits encoded.</p>
<p>This allows to set immediate values larger than 12 bits but loosing the possibility to encode some numbers. If you try to set one of those you will get a <em>invalid constant</em> error.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="nb">r2</span><span class="p">,</span><span class="w"> </span><span class="mi">128000</span><span class="w">  </span><span class="c1">;   r2 = 0x1f400</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="nb">r2</span><span class="p">,</span><span class="w"> </span><span class="mi">127999</span><span class="w">  </span><span class="c1">;   Invalid operand (KS_ERR_ASM_INVALIDOPERAND)</span><span class="w"></span>
</code></pre></div>

<p>More instructions are needed to compute an arbitrary 32 bits number or a load.</p>
<blockquote>
<p>Note: a 32 bit number can be set in two instructions: set the 16 lower bits with <code><span class="highlight-candombe-inline"><span class="nf">mov</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="c1">#&lt;imm16&gt;</span><span class="w"></span></span></code> and set the 16 upper bits with <em>move top</em>, <code><span class="highlight-candombe-inline"><span class="nf">movt</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="c1">#&lt;imm16&gt;</span><span class="w"></span></span></code></p>
</blockquote>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="nb">r2</span><span class="p">,</span><span class="w"> </span><span class="mh">0xccdd</span><span class="w">      </span><span class="c1">;   r2 = 0x0000ccdd</span><span class="w"></span>
<span class="w">    </span><span class="nf">movt</span><span class="w"> </span><span class="nb">r2</span><span class="p">,</span><span class="w"> </span><span class="mh">0xaabb</span><span class="w">     </span><span class="c1">;   r2 = 0xaabbccdd</span><span class="w"></span>
</code></pre></div>

<h2 id="registers">Registers</h2>
<p><code><span class="highlight-candombe-inline"><span class="nf">r0</span><span class="w"></span></span></code> to <code><span class="highlight-candombe-inline"><span class="nf">r3</span><span class="w"></span></span></code> are <em>scratch</em> registers: they are not preserved cross calls and it is caller’s responsibility to preserve them if needed.</p>
<p><code><span class="highlight-candombe-inline"><span class="nf">r4</span><span class="w"></span></span></code> to <code><span class="highlight-candombe-inline"><span class="nf">r11</span><span class="w"></span></span></code> are <em>variable</em> registers: they must be preserved cross calls and it is callee’s responsibility to preserve them if needed.</p>
<p><code><span class="highlight-candombe-inline"><span class="nf">r9</span><span class="w"></span></span></code> may play a different roll (platform dependent, known also as <em>static base</em> register or <code><span class="highlight-candombe-inline"><span class="nf">sb</span><span class="w"></span></span></code>) and <code><span class="highlight-candombe-inline"><span class="nf">r11</span><span class="w"></span></span></code> may play the roll of <code><span class="highlight-candombe-inline"><span class="nf">fp</span><span class="w"></span></span></code> so both may not be free for arbitrary usage.</p>
<p>The <code><span class="highlight-candombe-inline"><span class="nf">bl</span><span class="w"></span></span></code> instruction saves the next instruction (the <em>return address</em>) in the <em>link</em> <code><span class="highlight-candombe-inline"><span class="nf">lr</span><span class="w"></span></span></code> register (<code><span class="highlight-candombe-inline"><span class="nf">r14</span><span class="w"></span></span></code>) and set the destination address in the <em>program counter</em> <code><span class="highlight-candombe-inline"><span class="nf">pc</span><span class="w"></span></span></code> register (<code><span class="highlight-candombe-inline"><span class="nf">r15</span><span class="w"></span></span></code>).</p>
<p>For “long jumps” and inter-operability, the <em>intra-procedure-call</em> registry <code><span class="highlight-candombe-inline"><span class="nf">ip</span><span class="w"></span></span></code> (<code><span class="highlight-candombe-inline"><span class="nf">r12</span><span class="w"></span></span></code>) is used.</p>
<p><code><span class="highlight-candombe-inline"><span class="nf">r13</span><span class="w"></span></span></code> is the <em>stack pointer</em> <code><span class="highlight-candombe-inline"><span class="nf">sp</span><span class="w"></span></span></code>.</p>
<p>Take a look at the <a href="https://developer.arm.com/documentation/ihi0042/latest/">Procedure Call Standard for the Arm Architecture</a></p>
<h2 id="data-instructions">Data instructions</h2>
<p>The arithmetic and logical instructions fall in this category; they manipulate only on registers, never on memory.</p>
<p>The destination and the first operand are registers while the second can be a register, and immediate value or a register shifted by another register or immediate value.</p>
<p>They can be conditionally executed and conditionally set the status flags.</p>
<p>The <a href="https://documentation-service.arm.com/static/5ed66080ca06a95ce53f932d?token=">ARM and Thumb-2 Instruction Set Quick Reference Card</a> is your friend!</p>
<p>There are no division instructions except on ARMv7-R and ARMv7-M and multiplication operations are more special.</p>
<p>Because the registers are of 32 bits, the result of a multiplication cannot fit there: we need 64 bits!</p>
<p>There are two sets of multiplications: the one that stores the result in a 32 bits register (<code><span class="highlight-candombe-inline"><span class="nf">mul</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="nv">rm</span><span class="p">,</span><span class="w"> </span><span class="nv">rs</span><span class="w"></span></span></code>) and the one that stores it in two registers (<code><span class="highlight-candombe-inline"><span class="nf">umull</span><span class="w"> </span><span class="nv">rdlo</span><span class="p">,</span><span class="w"> </span><span class="nv">rdhi</span><span class="p">,</span><span class="w"> </span><span class="nv">rm</span><span class="w"> </span><span class="nv">rs</span><span class="w"></span></span></code>) – the extra <code><span class="highlight-candombe-inline"><span class="nf">l</span><span class="w"></span></span></code> means <code><span class="highlight-candombe-inline"><span class="nf">long</span><span class="w"></span></span></code>.</p>
<h2 id="memory-instructions-load-and-store">Memory instructions: load and store</h2>
<p>Loads and stores are quite similar: they can operate (load/store) on 32 bits words, half-words (<code><span class="highlight-candombe-inline"><span class="nf">h</span><span class="w"></span></span></code>) and bytes (<code><span class="highlight-candombe-inline"><span class="nf">b</span><span class="w"></span></span></code>), zero extended or signed extended (<code><span class="highlight-candombe-inline"><span class="nf">s</span><span class="w"></span></span></code>, <code><span class="highlight-candombe-inline"><span class="nf">sh</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">sb</span><span class="w"></span></span></code> respectively).</p>
<blockquote>
<p>Note: <code><span class="highlight-candombe-inline"><span class="nf">sb</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">sh</span><span class="w"></span></span></code> prefixes are not supported for stores.</p>
</blockquote>
<h3 id="indexing">Indexing</h3>
<p>In <code><span class="highlight-candombe-inline"><span class="nf">ldr</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nv">rn</span><span class="p">]</span><span class="w"></span></span></code> or <code><span class="highlight-candombe-inline"><span class="nf">str</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nv">rn</span><span class="p">]</span><span class="w"></span></span></code>, the <code><span class="highlight-candombe-inline"><span class="err">[</span><span class="w"> </span><span class="err">]</span><span class="w"></span></span></code> denotes dereferencing and the <code><span class="highlight-candombe-inline"><span class="nf">rn</span><span class="w"></span></span></code> register is the <em>base register</em>.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">]</span><span class="w">  </span><span class="c1">; r0 = stack top</span><span class="w"></span>
</code></pre></div>

<p>This is the <em>register indirect addressing</em>.</p>
<p>An offset can be added to the base register, useful to iterate over an array like <code><span class="highlight-candombe-inline"><span class="nf">ldr</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nv">rn</span><span class="p">,</span><span class="w"> </span><span class="nv">rm</span><span class="p">]</span><span class="w"></span></span></code>, <code><span class="highlight-candombe-inline"><span class="nf">ldr</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nv">rn</span><span class="p">,</span><span class="w"> </span><span class="c1">#4]</span><span class="w"></span></span></code> or even <code><span class="highlight-candombe-inline"><span class="nf">ldr</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nv">rn</span><span class="p">,</span><span class="w"> </span><span class="nv">rm</span><span class="p">,</span><span class="w"> </span><span class="nv">lsl</span><span class="w"> </span><span class="c1">#4]</span><span class="w"></span></span></code>.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">]</span><span class="w">                </span><span class="c1">; r0 = stack top</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">,</span><span class="w"> </span><span class="c1">#4]            ; r0 = elem below the top</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">,</span><span class="w"> </span><span class="nb">r3</span><span class="p">]</span><span class="w">            </span><span class="c1">; if r3 == 4, same above (sp + 4)</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">,</span><span class="w"> </span><span class="nb">r3</span><span class="p">,</span><span class="w"> </span><span class="nv">lsl</span><span class="w"> </span><span class="c1">#2]    ; if r3 == 2, same above (sp + (1 &lt;&lt; 2))</span><span class="w"></span>
</code></pre></div>

<p>This is known as <em>pre-index addressing</em>.</p>
<p>Note the use of squares in <code><span class="highlight-candombe-inline"><span class="nf">ldr</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nv">rn</span><span class="p">,</span><span class="w"> </span><span class="nv">rm</span><span class="p">,</span><span class="w"> </span><span class="nv">lsl</span><span class="w"> </span><span class="c1">#4]</span><span class="w"></span></span></code>, the instruction <code><span class="highlight-candombe-inline"><span class="nf">ldr</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nv">rn</span><span class="p">],</span><span class="w"> </span><span class="nv">rm</span><span class="p">,</span><span class="w"> </span><span class="nv">lsl</span><span class="w"> </span><span class="c1">#4</span><span class="w"></span></span></code> is a pre-index addressing <em>with post write-back</em>: the base address is updated with the final value <em>after</em> the load completed.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">],</span><span class="w"> </span><span class="c1">#4     ; r0 = stack top, sp move 4 down (aka &quot;pop&quot;)</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">],</span><span class="w"> </span><span class="c1">#4     ; r0 = next stack top, sp move 4 down (aka &quot;pop&quot;)</span><span class="w"></span>
</code></pre></div>

<p>A <em>pre write-back</em> variant exists: <code><span class="highlight-candombe-inline"><span class="nf">ldr</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nv">rn</span><span class="p">,</span><span class="w"> </span><span class="nv">rm</span><span class="p">,</span><span class="w"> </span><span class="nv">lsl</span><span class="w"> </span><span class="c1">#4]!</span><span class="w"></span></span></code>.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">,</span><span class="w"> </span><span class="c1">#4]!    ; r0 = sp move 4 down then load (top was skipped)</span><span class="w"></span>
</code></pre></div>

<blockquote>
<p>Note: <em>pre write-back</em> makes more sense for stores (aka pushes) and <em>post write-back</em> for loads (aka pops)</p>
</blockquote>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="c1">; swap r0, r1 using the stack, really slow!</span><span class="w"></span>
<span class="w">    </span><span class="nf">str</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">,</span><span class="w"> </span><span class="c1">#-4]!    ; r0 = sp move 4 up then store (aka push)</span><span class="w"></span>
<span class="w">    </span><span class="nf">str</span><span class="w"> </span><span class="nb">r1</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">,</span><span class="w"> </span><span class="c1">#-4]!    ; r1 = sp move 4 up then store (aka push)</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">],</span><span class="w"> </span><span class="c1">#4      ; r0 = stack top, sp move 4 down (aka &quot;pop&quot;)</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldr</span><span class="w"> </span><span class="nb">r1</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="nb">sp</span><span class="p">],</span><span class="w"> </span><span class="c1">#4      ; r1 = stack top, sp move 4 down (aka &quot;pop&quot;)</span><span class="w"></span>
</code></pre></div>

<p><em>PC-relative addressing</em> allows to load a memory which address is an offset of the program counter: <code><span class="highlight-candombe-inline"><span class="nf">ldr</span><span class="w"> </span><span class="nv">rd</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">label</span><span class="o">&gt;</span><span class="w"></span></span></code>. This works only for loads; useful to load numbers that cannot fit in an <code><span class="highlight-candombe-inline"><span class="nf">imm8</span><span class="w"></span></span></code>.</p>
<blockquote>
<p>Not all the combinations of sizes and addressing are possible. Check the data sheet.</p>
</blockquote>
<h3 id="bulk-loadstore">Bulk load/store</h3>
<p>Several registers can be loaded or stored with a single <em>load multiple</em> (<code><span class="highlight-candombe-inline"><span class="nf">ldm</span><span class="w"></span></span></code>) and <em>store multiple</em> (<code><span class="highlight-candombe-inline"><span class="nf">stm</span><span class="w"></span></span></code>) instructions.</p>
<p>They have a base address, a <em>set</em> of registers and an <em>indexing affix</em> which controls how to “iterate the array/memory”.</p>
<p>Four indexing exists: increment of the base address after/before accessing the memory (<code><span class="highlight-candombe-inline"><span class="nf">ia</span><span class="w"></span></span></code>/<code><span class="highlight-candombe-inline"><span class="nf">ib</span><span class="w"></span></span></code>) and decrement of the base address after/before (<code><span class="highlight-candombe-inline"><span class="nf">da</span><span class="w"></span></span></code>/<code><span class="highlight-candombe-inline"><span class="kd">db</span><span class="w"></span></span></code>).</p>
<p><code><span class="highlight-candombe-inline"><span class="nf">ia</span><span class="w"></span></span></code> is the default.</p>
<p>In short:</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">                            </span><span class="c1">;              r4, r5, r6, r7</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldmia</span><span class="w">   </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="err">{</span><span class="nb">r4</span><span class="o">-</span><span class="nb">r7</span><span class="err">}</span><span class="w">     </span><span class="c1">;  *src++    :  0,  1,  2,  3</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldmib</span><span class="w">   </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="err">{</span><span class="nb">r4</span><span class="o">-</span><span class="nb">r7</span><span class="err">}</span><span class="w">     </span><span class="c1">;  *++src    :  1,  2,  3,  4</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldmda</span><span class="w">   </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="err">{</span><span class="nb">r4</span><span class="o">-</span><span class="nb">r7</span><span class="err">}</span><span class="w">     </span><span class="c1">;  *src--    : -3, -2, -1,  0</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldmdb</span><span class="w">   </span><span class="nb">r0</span><span class="p">,</span><span class="w"> </span><span class="err">{</span><span class="nb">r4</span><span class="o">-</span><span class="nb">r7</span><span class="err">}</span><span class="w">     </span><span class="c1">;  *--src    : -4, -3, -2, -1</span><span class="w"></span>
</code></pre></div>

<p>Note the it is a <em>set</em> of registers, <strong>not a list</strong> so the order is not important. The registers are loaded/stored by their index from <code><span class="highlight-candombe-inline"><span class="nf">r0</span><span class="w"></span></span></code> to <code><span class="highlight-candombe-inline"><span class="nf">r15</span><span class="w"></span></span></code>.</p>
<p>For loads the registers are loaded from memory into the registers in the natural order: from <code><span class="highlight-candombe-inline"><span class="nf">r0</span><span class="w"></span></span></code> to <code><span class="highlight-candombe-inline"><span class="nf">r15</span><span class="w"></span></span></code>. For stores, the registers are dump into memory in the reverse order.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">            </span><span class="err">&lt;------</span><span class="w"> </span><span class="nf">store</span><span class="w"> </span><span class="nv">direction</span><span class="w">    </span><span class="o">&lt;------</span><span class="w"> </span><span class="nv">stack</span><span class="w"> </span><span class="nv">grows</span><span class="w"></span>
<span class="w">    </span><span class="nf">stmdb</span><span class="w"> </span><span class="nb">sp</span><span class="err">!</span><span class="p">,</span><span class="w">  </span><span class="err">{</span><span class="nb">r0</span><span class="p">,</span><span class="nb">r1</span><span class="err">}</span><span class="w">    </span><span class="c1">; stack top -&gt; [r0  r1]</span><span class="w"></span>
<span class="w">    </span><span class="nf">ldmia</span><span class="w"> </span><span class="nb">sp</span><span class="err">!</span><span class="p">,</span><span class="w">  </span><span class="err">{</span><span class="nb">r2</span><span class="p">,</span><span class="nb">r3</span><span class="err">}</span><span class="w">    </span><span class="c1">; r2 = r0; r3 = r1</span><span class="w"></span>
<span class="w">        </span><span class="nf">load</span><span class="w"> </span><span class="nv">direction</span><span class="w"> </span><span class="o">------&gt;</span><span class="w">     </span><span class="nv">stack</span><span class="w"> </span><span class="nv">shrinks</span><span class="w"> </span><span class="o">----&gt;</span><span class="w"></span>
</code></pre></div>

<p>The additional <code><span class="highlight-candombe-inline"><span class="err">!</span><span class="w"></span></span></code> symbol means update the base register <em>before</em> the load or store but it doesn’t change how the load/store works.</p>
<p>The data sheet says that <code><span class="highlight-candombe-inline"><span class="nf">push</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">pop</span><span class="w"></span></span></code> have the canonical form of <code><span class="highlight-candombe-inline"><span class="nf">stmdb</span><span class="w"> </span><span class="nb">sp</span><span class="err">!</span><span class="p">,</span><span class="w"> </span><span class="err">{</span><span class="nv">regs</span><span class="err">}</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">ldmia</span><span class="w"> </span><span class="nb">sp</span><span class="err">!</span><span class="p">,</span><span class="w"> </span><span class="err">{</span><span class="nv">regs</span><span class="err">}</span><span class="w"></span></span></code> respectively.</p>
<blockquote>
<p>Note that <code><span class="highlight-candombe-inline"><span class="nf">sp</span><span class="w"></span></span></code> points to the last value of the stack and <code><span class="highlight-candombe-inline"><span class="nf">stmdb</span><span class="w"></span></span></code> decrements the base address (<code><span class="highlight-candombe-inline"><span class="nf">sp</span><span class="w"></span></span></code>) before doing the store in a <code><span class="highlight-candombe-inline"><span class="nf">push</span><span class="w"></span></span></code> while <code><span class="highlight-candombe-inline"><span class="nf">ldmia</span><span class="w"></span></span></code> increments after the load in a <code><span class="highlight-candombe-inline"><span class="nf">pop</span><span class="w"></span></span></code>.</p>
<p>In both cases the <code><span class="highlight-candombe-inline"><span class="nf">sp</span><span class="w"></span></span></code> is updated <em>before</em> (<em>pre write-back</em>) regardless of <code><span class="highlight-candombe-inline"><span class="kd">db</span><span class="w"></span></span></code>/<code><span class="highlight-candombe-inline"><span class="nf">ia</span><span class="w"></span></span></code>.</p>
<p>Note also that the stack grows decrementing the addresses and shrinks incrementing the addresses.</p>
</blockquote>
<h3 id="alignment">Alignment</h3>
<p>The assembler can do it for you: <code><span class="highlight-candombe-inline"><span class="nf">.align</span><span class="w"> </span><span class="nv">n</span><span class="w"></span></span></code> aligns the code or data to 2^n bytes.</p>
<h3 id="endianess">Endianess</h3>
<p>Since version 3, Arm is bi-endian. The instructions are in little endian but the data access can be little or big endian controlled by the <code><span class="highlight-candombe-inline"><span class="nf">E</span><span class="w"></span></span></code> flag of CPSR.</p>
<h2 id="conditionals-and-branches">Conditionals and branches</h2>
<p>Three branches: <em>branch</em> (<code><span class="highlight-candombe-inline"><span class="nf">b</span><span class="w"></span></span></code>) for <code><span class="highlight-candombe-inline"><span class="nf">if</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">while</span><span class="w"></span></span></code> constructs, <em>branch with link</em> (<code><span class="highlight-candombe-inline"><span class="nf">bl</span><span class="w"></span></span></code>) for function call and <em>branch with exchange</em> (<code><span class="highlight-candombe-inline"><span class="nf">bx</span><span class="w"></span></span></code>) for returning from a call or to switch between Arm and Thumb modes.</p>
<p>The first two receive a label while the last one operates with a register.</p>
<p>More branches exist including <em>branch with change to Jazelle</em> (<code><span class="highlight-candombe-inline"><span class="nf">bxj</span><span class="w"></span></span></code>) which can switch to a special mode that <a href="https://en.wikipedia.org/wiki/Jazelle">executes Java bytecode</a> if supported.</p>
<p>Due instruction size constrains, labels cannot be in arbitrary positions. The <code><span class="highlight-candombe-inline"><span class="nf">b</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">bl</span><span class="w"></span></span></code> requires the destination addresses to be in a range relative to <code><span class="highlight-candombe-inline"><span class="nf">PC</span><span class="w"></span></span></code> of [-32MB;+32MB].</p>
<p>The range shrinks for other flavours of Arm to [-16MB;+16MB] and to [-252,256].</p>
<p>The branches can, as other instructions, be conditional executed. So <code><span class="highlight-candombe-inline"><span class="nf">bne</span><span class="w"></span></span></code> stands for branch if not equals.</p>
<p>Two registers have the flags that controls the conditional execution: the <em>Current Program Status Register</em> (CPSR) and the <em>Saved Program Status Register</em> (SPSR), used during the interrupt handling.</p>
<p>The flags are set by special instructions like <em>compare</em> (<code><span class="highlight-candombe-inline"><span class="nf">cmp</span><span class="w"></span></span></code>) or by data manipulation instructions if the affix <code><span class="highlight-candombe-inline"><span class="nf">s</span><span class="w"></span></span></code> is added like in <code><span class="highlight-candombe-inline"><span class="nf">adds</span><span class="w"></span></span></code>.</p>
<p>Not all the data manipulation instructions alter all the flags. For example the <em>overflow</em> flag (<code><span class="highlight-candombe-inline"><span class="nf">v</span><span class="w"></span></span></code>) is set by arithmetic operations and not by bit operations.</p>
<h3 id="branching-and-condition-codes">Branching and condition codes</h3>
<p>Current Program Status Register (CPSR):</p>
<ul>
<li>Z: is zero?</li>
<li>N: is negative? (is MSB set?)</li>
<li>C: is carry bit set? (in a 32 bit register with bits numbered from 0 (LSB) to 31 (MSB), is the 32 bit set?)</li>
<li>V: was an arithmetic overflow? (like given a&gt;0 &amp; b&gt;0 and then a+b &lt; 0)</li>
<li>E: are we in big endian mode (E==1) or in little endian (E==0)?</li>
</ul>
<h2 id="symbols">Symbols</h2>
<p>Global labels are defined with <code><span class="highlight-candombe-inline"><span class="nf">.global</span><span class="w"> </span><span class="nv">label</span><span class="w"></span></span></code> while local labels are just <code><span class="highlight-candombe-inline"><span class="nf">.label</span><span class="w"></span></span></code> (conventionally they begin with <code><span class="highlight-candombe-inline"><span class="nf">L</span><span class="w"></span></span></code> to denote local but it is optional)</p>
<p><code><span class="highlight-candombe-inline"><span class="nf">.code</span><span class="w"> </span><span class="nv">n</span><span class="w"></span></span></code> declares the type of code: Arm (<code><span class="highlight-candombe-inline"><span class="nf">n</span><span class="w"></span></span></code> is 32) or Thumb (<code><span class="highlight-candombe-inline"><span class="nf">n</span><span class="w"></span></span></code> is 16). Alternative there are <code><span class="highlight-candombe-inline"><span class="nf">.arm</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">.thumb</span><span class="w"></span></span></code> directives that do the same.</p>
<p>These affect all the code below until another directive change the setting.</p>
<p><code><span class="highlight-candombe-inline"><span class="nf">.thumb_func</span><span class="w"></span></span></code> on the other side affects only to the next symbol and it is required for <em>interworking</em> Thumb functions.</p>
<p>Alignment of code and data can be set by <code><span class="highlight-candombe-inline"><span class="nf">.aling</span><span class="w"> </span><span class="nv">n</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">.baling</span><span class="w"> </span><span class="nv">m</span><span class="w"></span></span></code> where the former aligns to <code><span class="highlight-candombe-inline"><span class="err">2^</span><span class="nf">n</span><span class="w"></span></span></code> bytes and the latter to <code><span class="highlight-candombe-inline"><span class="nf">m</span><span class="w"></span></span></code> bytes.</p>
<p>They apply to the next instruction/data, they are not global.</p>
<p><code><span class="highlight-candombe-inline"><span class="nf">.type</span><span class="w"> </span><span class="nv">funcname</span><span class="w"> </span><span class="o">%</span><span class="nv">function</span><span class="w"></span></span></code> declares a function.</p>
<h2 id="definition-of-variables">Definition of variables</h2>
<p><code><span class="highlight-candombe-inline"><span class="nf">.byte</span><span class="w"></span></span></code>, <code><span class="highlight-candombe-inline"><span class="nf">.hword</span><span class="w"></span></span></code> and <code><span class="highlight-candombe-inline"><span class="nf">.word</span><span class="w"></span></span></code> define data, array of items of 1, 2 and 4 bytes each.</p>
<p>This is handy way to define <em>“variables”</em> in the code:</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">.align</span><span class="w"> </span><span class="mi">2</span><span class="w">            </span><span class="c1">;  mantain the alignment, always!</span><span class="w"></span>
<span class="nl">one_word:</span><span class="w"></span>
<span class="w">    </span><span class="nf">.word</span><span class="w"> </span><span class="mh">0x41424344</span><span class="w"></span>
<span class="nl">one_array_u16:</span><span class="w"></span>
<span class="w">    </span><span class="nf">.hword</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="nl">hello:</span><span class="w"></span>
<span class="w">    </span><span class="nf">.string</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello world!&quot;</span><span class="w">   </span><span class="c1">;  array of NULL-terminated strings</span><span class="w"></span>
</code></pre></div>

<h2 id="sections">Sections</h2>
<p>These are <code><span class="highlight-candombe-inline"><span class="nf">.data</span><span class="w"></span></span></code> (read-write non-zero initialized data) and <code><span class="highlight-candombe-inline"><span class="nf">.bss</span><span class="w"></span></span></code> (read-write zero initialized data).</p>
<p>Other sections exist as well and they are denoted with <code><span class="highlight-candombe-inline"><span class="nf">.section</span><span class="w"></span></span></code> like <code><span class="highlight-candombe-inline"><span class="nf">.section</span><span class="w"> </span><span class="nv">.rodata</span><span class="w"></span></span></code> for read-only data.</p>
<div class="highlight-candombe"><pre><span></span><code><span class="w">    </span><span class="nf">.data</span><span class="w"></span>
<span class="w">    </span><span class="nf">.align</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="nl">magic:</span><span class="w"></span>
<span class="w">    </span><span class="nf">.word</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>

<span class="w">    </span><span class="nf">.bss</span><span class="w"></span>
<span class="nl">counter:</span><span class="w"></span>
<span class="w">    </span><span class="nf">.space</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
</code></pre></div>

<p>Code section is denoted by <code><span class="highlight-candombe-inline"><span class="nf">.text</span><span class="w"></span></span></code></p>
<h1 id="references">References</h1>
<ul>
<li><p><a href="https://www.coranac.com/tonc/text/asm.htm">Whirlwind Tour of ARM Assembly</a>.</p></li>
<li><p><a href="https://documentation-service.arm.com/static/5ed66080ca06a95ce53f932d?token=">ARM and Thumb-2 Instruction Set Quick Reference Card</a></p></li>
<li><p><a href="https://developer.arm.com/documentation/ihi0042/latest/">Procedure Call Standard for the Arm Architecture</a></p>
</article>
<span class="print-footer">TL;DR Quick Overview of Arm - December 27, 2020 - Martin Di Paola</span>
<footer>
<hr class="slender">
<div class="credits">
    <span>&copy;
        Martin Di Paola
    </span></br>
        <a class="raw_link" href="/feed.xml"><img height="16px" width="16px" src="/img/rss-32px.png" /></a>
        <a class="raw_link" href="https://github.com/eldipa"><img height="16px" width="16px" src="/img/github.png" /></a>
    <br>

    <a href="mailto:martinp.dipaola@gmail.com">martinp.dipaola@gmail.com</a></span></br> <br>

</div>
</footer></li>
</ul>
</body>
</html>
