<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>iasm: Interactive Assembler</title>
  <meta name="description" content="I crossed with a series of Arm challengesby causality and I decided to give it a shoot.But I have 0 knowledge about Arm so the disassembly of the binarieswer...">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2021/01/09/Interactive-Assembler.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>iasm: Interactive Assembler</h1>
<p class="subtitle">January 9, 2021</p>

<p>I crossed with a series of <a href="https://github.com/azeria-labs/ARM-challenges">Arm challenges</a>
by causality and I decided to give it a shoot.</p>

<p>But I have <strong>0</strong> knowledge about Arm so the disassembly of the binaries
were too strange for me.</p>

<p>I stepped back to plan it better: my idea was to use GDB to debug small snippets of Arm
code, learn about it before jumping into the challenges.</p>

<p>I setup a <a href="/book-of-gehn/articles/2020/12/15/Qemulating-Rasbian-ARM.html">QEMU virtual machine</a>
running Rasbian in an Arm CPU.</p>

<p>With a GCC and GDB running there I started but the compile-load-debug
cycle was too inflexible.</p>

<p>I could not use it to <em>explore</em>.</p>

<p>If I wanted to see the effect of a particular instruction I needed to write
it in assembly, compile it and debug it.</p>

<p>And the time between the “what does X?” and the “X does this” was too
large, reducing the <em>momentum</em> that you have when you explore something
new.</p>

<p>Too tedious.</p>

<p>So I decided to shorten the cycle writing an
<a href="https://github.com/bad-address/iasm"><em>interactive</em> assembler</a>.<!--more--></p>

<h2 id="first-try-gdb-as-the-engine">First try: GDB as the engine</h2>

<p>GDB can manipulate the memory of the debuggee process. In particular we
could write binary code, jump to it and execute it. Perfect.</p>

<p>But GDB doesn’t have a compiler for assembly.</p>

<p>Or has it?</p>

<h3 id="keystone-engine">Keystone engine</h3>

<p>No, but one can be implemented easily with
<a href="https://www.keystone-engine.org/">keystone-engine</a>.</p>

<p>Keystone takes assembly code and compiles it. Having Python bindings
we could put this into a GDB plugin and <em>presto!</em></p>

<h2 id="second-try-unicorn-engine">Second try: Unicorn engine</h2>

<p>GDB requires a full operative
system (Rasbian) running in a full emulated QEMU machine.</p>

<p>Can we make it lighter? – Yes we can.</p>

<h3 id="unicorn-engine">Unicorn engine</h3>

<p><a href="https://www.unicorn-engine.org/">unicorn-engine</a> it is a CPU emulator
based on QEMU.</p>

<p>The trick is that Unicorn only emulates the CPU and memory and nothing
else: no devices, disks or network cards.</p>

<p>Without anything to manage, Unicorn does not need an operative system
making it a solution much lighter.</p>

<p>And better, the Python bindings for Unicorn gives us access to the CPU
registers and memory so we can get rid of GDB.</p>

<h2 id="iasm-keystone--unicorn--python">iasm: keystone + unicorn + python</h2>

<p>I soon realized that while learning Arm by writing code is the best way
to do it,
writing <em>everything</em> in assembly is hard.</p>

<p>Simple tasks like initialize the registers or print a chunk
of stack involves several instructions.</p>

<p>In Python <code class="highlighter-rouge">r0 = 1111127999</code>. In Arm:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">100</span><span class="o">:</span><span class="mi">0</span><span class="o">&gt;</span>     <span class="n">ldr</span> <span class="n">r0</span><span class="p">,</span> <span class="p">.</span><span class="n">Lval</span>
<span class="mi">100</span><span class="o">:</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="mi">100</span><span class="o">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">.</span><span class="n">Lval</span><span class="o">:</span>
<span class="mi">100</span><span class="o">:</span><span class="mi">0</span><span class="o">&gt;</span>     <span class="p">.</span><span class="n">word</span> <span class="mi">1111127999</span>
</code></pre></div></div>

<p>So, <a href="https://github.com/bad-address/iasm"><code class="highlighter-rouge">iasm</code></a> has an escape mode.
Basically I call <code class="highlighter-rouge">eval</code>/<code class="highlighter-rouge">exec</code>
emulating with Python variables like <code class="highlighter-rouge">r0</code> and <code class="highlighter-rouge">M</code> registers
and memory.</p>

<p>And that’s <code class="highlighter-rouge">iasm</code> an keystone assembler connected with a unicorn
emulator and some python code to glue them.</p>

<h2 id="features">Features</h2>

<h3 id="python-prompt-toolkit">Python Prompt Toolkit</h3>

<p><a href="https://python-prompt-toolkit.readthedocs.io/en/latest/">python-prompt-toolkit</a>
or PPT for short, is a library to build CLI applications.</p>

<p>It has syntax highlighting as you write (using <a href="https://pygments.org/">pygments</a>),
autocompletion and command line history.</p>

<p>An enhanced replacement for Python’s <code class="highlighter-rouge">input</code> for sure.</p>

<h3 id="memory">Memory</h3>

<p>Unicorn has <code class="highlighter-rouge">mem_read</code> and <code class="highlighter-rouge">mem_write</code> to change the memory of the
process but like any other process, the memory pages need to be mapped
before with <code class="highlighter-rouge">mem_map</code> and released with <code class="highlighter-rouge">mem_unmap</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mu</span><span class="o">.</span><span class="n">mem_map</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">)</span>
<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="mh">0x1100</span><span class="p">,</span> <span class="mh">0x1200</span><span class="p">,</span> <span class="n">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mh">0x100</span><span class="p">)</span>
<span class="n">mu</span><span class="o">.</span><span class="n">mem_read</span><span class="p">(</span><span class="mh">0x1100</span><span class="p">,</span> <span class="mh">0x1200</span><span class="p">)</span>
<span class="n">mu</span><span class="o">.</span><span class="n">mem_unmap</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">iasm</code> has a more pythonic syntax accessible from the Python shell:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="n">M</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">:</span><span class="mh">0x2000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># map and initialize
</span><span class="n">Mapping</span> <span class="n">memory</span> <span class="n">region</span> <span class="p">[</span><span class="mh">0x1000</span><span class="o">-</span><span class="mh">0x1fff</span><span class="p">]</span> <span class="p">(</span><span class="n">sz</span> <span class="mh">0x1000</span><span class="p">)</span>

<span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="n">M</span><span class="p">[</span><span class="mh">0x1050</span><span class="p">:</span><span class="mh">0x1055</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x41</span>       <span class="c1"># write like 'memset'
</span><span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="n">M</span><span class="p">[</span><span class="mh">0x1055</span><span class="p">:</span><span class="mh">0x105a</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s">'B'</span> <span class="o">*</span> <span class="mi">5</span>   <span class="c1"># write like 'memcpy'
</span>
<span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="n">M</span><span class="p">[</span><span class="mh">0x1050</span><span class="p">:</span><span class="mh">0x105a</span><span class="p">]</span>     <span class="c1"># read
</span><span class="p">[</span><span class="n">AAAAABBBBB</span><span class="p">]</span>

<span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="n">M</span>    <span class="c1"># list mapped pages
</span><span class="p">[</span><span class="mh">0x1000</span><span class="o">-</span><span class="mh">0x1fff</span><span class="p">]</span> <span class="p">(</span><span class="n">sz</span> <span class="mh">0x1000</span><span class="p">)</span>
<span class="p">[</span><span class="mh">0x1000000</span><span class="o">-</span><span class="mh">0x11fffff</span><span class="p">]</span> <span class="p">(</span><span class="n">sz</span> <span class="mh">0x200000</span><span class="p">)</span>

<span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="k">del</span> <span class="n">M</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">:</span><span class="mh">0x2000</span><span class="p">]</span>    <span class="c1"># unmap
</span></code></pre></div></div>

<h3 id="allocate-stack">Allocate stack</h3>

<p>To allocate the stack and setup the (Arm) registers just run:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="n">M</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">:</span><span class="mh">0x2000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Mapping</span> <span class="n">memory</span> <span class="n">region</span> <span class="p">[</span><span class="mh">0x1000</span><span class="o">-</span><span class="mh">0x1fff</span><span class="p">]</span> <span class="p">(</span><span class="n">sz</span> <span class="mh">0x1000</span><span class="p">)</span>

<span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">sp</span> <span class="o">=</span> <span class="mh">0x2000</span>
</code></pre></div></div>

<p>Now, play with it and practice your (Arm) assembly:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">100</span><span class="o">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="err">#</span><span class="mi">4</span>
<span class="mi">100</span><span class="o">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="err">#</span><span class="mi">8</span>
<span class="mi">100</span><span class="o">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">push</span> <span class="err">{</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="err">}</span>
</code></pre></div></div>

<p>And check the stack (was <code class="highlighter-rouge">r0</code> pushed before <code class="highlighter-rouge">r1</code> or not? Check it!)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">100</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span><span class="err">!</span> <span class="n">M</span><span class="p">[</span><span class="n">sp</span><span class="p">:]</span>   <span class="c1"># from sp to the end of the mapped page
</span><span class="p">[</span>\<span class="n">x04</span>\<span class="n">x00</span>\<span class="n">x00</span>\<span class="n">x00</span>\<span class="n">x08</span>\<span class="n">x00</span>\<span class="n">x00</span>\<span class="n">x00</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="initialization-script">Initialization script</h3>

<p>Write in a file all the initialization like the stack allocation and
load it from the command line with <code class="highlighter-rouge">-i</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s1">';! r0 = r1 = r2 = 8'</span> <span class="o">&gt;</span> init

<span class="nv">$ </span>iasm <span class="nt">-a</span> arm <span class="nt">-m</span> arm <span class="nt">-i</span> init
Mapping memory region <span class="o">[</span>0x1000000-0x11fffff] <span class="o">(</span>sz 0x200000<span class="o">)</span>
<span class="nt">------</span>  -  <span class="nt">------</span>  -  <span class="nt">------</span>  -  <span class="nt">------</span>  <span class="nt">-----</span>
    r0  8  r1      8  r2      8  r3      0
&lt;...&gt;
</code></pre></div></div>

<h3 id="inline-documentation">Inline documentation</h3>

<p>Following the tradition of Python, <code class="highlighter-rouge">iasm</code> includes documentation for the
assembly instructions.</p>

<p>After the mnemonic type <code class="highlighter-rouge">?</code> and enter to show it:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">100</span><span class="o">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">mul</span> <span class="o">?</span>
<span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Basically what I did was to convert to text the manual of reference of
the ISA (typically it is a PDF file) and then parse the text.</p>

<p>I only focused in the documentation of the instructions, the rest is up
to the user to search the complete story in the official documentation
(only Arm for now)</p>

<h3 id="globs-registers">Globs registers</h3>

<p><code class="highlighter-rouge">iasm</code> allows to select which registers to show using <em>globs</em>,
Unix like pattern expressions defined by
<a href="https://docs.python.org/3/library/fnmatch.html">fnmatch</a>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>iasm <span class="nt">-a</span> arm <span class="nt">-m</span> arm <span class="nt">-r</span> <span class="s1">'r[0-9]'</span>
Mapping memory region <span class="o">[</span>0x1000000-0x11fffff] <span class="o">(</span>sz 0x200000<span class="o">)</span>
<span class="nt">--</span>  -  <span class="nt">-----</span>  -  <span class="nt">--</span>  -  <span class="nt">--</span>  -
r0  0  r1     0  r2  0  r3  0
r4  0  r5     0  r6  0  r7  0
r8  0  r9/sb  0
<span class="nt">--</span>  -  <span class="nt">-----</span>  -  <span class="nt">--</span>  -  <span class="nt">--</span>  -
&lt;...&gt;
</code></pre></div></div>

<p>So the expression <code class="highlighter-rouge">r[0-9]</code> selects all the Arm registers from <code class="highlighter-rouge">r0</code> to
<code class="highlighter-rouge">r15</code>.</p>

<h3 id="compressed-hex-values">Compressed hex values</h3>

<p>32 bit numbers are too large to display (and 64 bit address are
worse!).</p>

<p>Instead, <code class="highlighter-rouge">iasm</code> shows them as <em>compressed</em> hexadecimal numbers.</p>

<p>They are like hexadecimals but the number is split into 4-digits groups
divided by a <code class="highlighter-rouge">:</code>.</p>

<p>The leading zeros of each group are omitted and if the group is full of
zeros only a single <code class="highlighter-rouge">0</code> is put and if the group is on the left (more
significant digits), the whole group is omitted.</p>

<p>Here are some examples:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x00000000             0
0x000000ab            ab
0x00ab00cd         ab:cd
0x00ab0000          ab:0
</code></pre></div></div>



    </article>
    <span class="print-footer">iasm: Interactive Assembler - January 9, 2021 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
