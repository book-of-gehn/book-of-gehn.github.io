<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Necklaces, Lyndon words and De Bruijn Sequences</title>
  <meta name="description" content="What have in common a dense arrays for mapping numbers power of 2to some objects, DNA sequencing and brute-forcing the lock padof your neighbor?">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2021/02/15/Necklaces-Lyndon-Words-and-De-Bruijn-Sequences.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>Necklaces, Lyndon words and De Bruijn Sequences</h1>
<p class="subtitle">February 15, 2021</p>

<p>What have in common a dense arrays for mapping numbers power of 2
to some objects, DNA sequencing and brute-forcing the lock pad
of your neighbor?<!--more--></p>

<h2 id="substrings">Substrings</h2>

<p>Given an alphabet of <script type="math/tex">k</script> symbols, you can build strings
of length <script type="math/tex">n</script> from it.</p>

<p>For a binary alphabet <script type="math/tex">{0,1}</script> these are the strings of length 4:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000    0100    1000    1100
0001    0101    1001    1101
0010    0110    1010    1110
0011    0111    1011    1111
</code></pre></div></div>

<p>A set of elements like the strings above can be <em>classified</em>: choose
a <em>relationship</em> among the elements and build a class where all the
elements of the class have the same relation.</p>

<p>Mathematically, each class is defined as</p>

<script type="math/tex; mode=display">C = { x \in X \vert a \sim x }</script>

<p>Where <script type="math/tex">a</script> is one element of the set <script type="math/tex">X</script> that is used as a reference.</p>

<p>For example, we can classify the binary strings in two classes: the
ones that have its last bit equal to 0 and the ones which don’t.</p>

<p>In other words: the even and the odd numbers.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000    0100    |    0001    0101
0010    0110    |    0011    0111
1000    1100    |    1001    1101
1010    1110    |    1011    1111
</code></pre></div></div>

<p>In mathematics jargon, each class is an <a href="https://en.wikipedia.org/wiki/Equivalence_class">equivalence
class</a> and the relation
used to group them is an <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence
relation</a>.</p>

<h2 id="necklaces">Necklaces</h2>

<p>The relation <script type="math/tex">x \sim a</script> is quite arbitrary; another relation could
be the strings of length 4 that are a <em>rotation</em> of another string.</p>

<p>This generates 6 classes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000  |  0001  |  0011  |  0101  |  0111  |  1111
      |  0010  |  0110  |  1010  |  1101  |
      |  0100  |  1100  |        |  1011  |
      |  1000  |  1001  |        |  1110  |
</code></pre></div></div>

<p>Each <a href="https://en.wikipedia.org/wiki/Equivalence_class">equivalence class</a>
generated from strings of length <script type="math/tex">n</script> from an alphabet of <script type="math/tex">k</script> elements
which <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence
relation</a> is the
rotation has the special names of
<a href="https://en.wikipedia.org/wiki/Necklace_(combinatorics)">necklaces</a>.</p>

<p>The above 6 classes are 6 necklaces for <script type="math/tex">k=2</script> and <script type="math/tex">n=4</script>.</p>

<h2 id="aperiodic-necklaces">Aperiodic necklaces</h2>

<p>As you notice how many elements a necklace has varies. The necklace
generated from all the rotations of 0000 has only one element: {0000};
while the necklace generated from 0001 has 4 elements: {0001, 0010,
0100 and 1000}.</p>

<p>These are two extremes. A middle point is the necklace {0101, 1010}.</p>

<p>You see, if you pick a string and you start rotating it you may
find yourself with the same initial string <strong>before</strong> doing
a complete wrap-around.</p>

<p>Pick 0101, rotate it once and you get 1010, and once more and you
get the original 0101.</p>

<p>If you do the same with 0001 you will find that you need to perform
4 rotations to get the initial string.</p>

<p>An <em>aperiodic</em> sequence respect the rotation are the strings of
length <script type="math/tex">n</script> that you need to perform exactly <script type="math/tex">n</script> rotations to get the
initial strings.</p>

<p>Therefore the necklace that contains them has exactly <script type="math/tex">n</script> elements
and it is known as <em>aperiodic necklace</em>.</p>

<p><label for="mn-679a720680e4ccdf07926fb2d4db4e2b" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-679a720680e4ccdf07926fb2d4db4e2b" class="margin-toggle" /><span class="marginnote">You may find multiple substrings that repeated form the same
string. For example 01010101 can be formed repeating 0101 twice
or 01 four times.
<br />
The fact is that 0101 is in turn periodic. The substring which it
is <em>aperiodic</em> is called the <em>aperiodic reduction</em> of the original
string.
<br />
In our case, 01 is the aperiodic reduction of 0101 and of 01010101.
 </span></p>

<p>In contrast, a <em>periodic</em> sequence is a string that is the
repetition of a substring that repeats so less rotations are required to
get the initial string and therefore the necklace has less than $$n$
elements.</p>

<p>The 0101 is formed by the substring 01 repeated twice.</p>

<p>The analysis of the periodicity of the 6 necklaces follows with the
substrings between parenthesis:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0)   |    aperiodic   |  (01)  |  aperiodic |  (1)
0000  |  0001  |  0011 |  0101  |    0111    |  1111
      |  0010  |  0110 |  1010  |    1101    |
      |  0100  |  1100 |        |    1011    |
      |  1000  |  1001 |        |    1110    |
</code></pre></div></div>

<h2 id="lyndon-words">Lyndon words</h2>

<p>We focus now in only the aperiodic necklaces:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0001  |  0011  |  0111
0010  |  0110  |  1101
0100  |  1100  |  1011
1000  |  1001  |  1110
</code></pre></div></div>

<p>If the alphabet supports a total order, more specifically
a <a href="https://en.wikipedia.org/wiki/Lexicographic_order">lexicographic order</a>,
we can sort the elements of each necklace.</p>

<p>Basically we get <script type="math/tex">% <![CDATA[
0001 < 0010 < 0100 < 1000 %]]></script>.</p>

<p>For each aperiodic necklace we keep only the <em>smallest</em>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0001  |  0011  |  0111
</code></pre></div></div>

<p>These strings define the <a href="https://en.wikipedia.org/wiki/Lyndon_word">Lyndon
words</a> of length <script type="math/tex">n</script>
for the alphabet <script type="math/tex">{0,1}</script> (<script type="math/tex">k=2</script>).</p>

<p>More generally the <a href="https://en.wikipedia.org/wiki/Lyndon_word">Lyndon
words</a> are the smallest strings of the
aperiodic necklaces for <em>all</em> the strings of <em>any</em> length <script type="math/tex">n</script> for an
alphabet of <script type="math/tex">k</script> elements.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0, 1, 01, 001, 011, 0001, 0011, 0111, 00001, 00011, 00101, ...
</code></pre></div></div>

<h2 id="de-bruijn-sequence">De Bruijn sequence</h2>

<p>Choose a natural number <script type="math/tex">n</script>. Select the Lyndon words that have a
length that <em>divides</em> <script type="math/tex">n</script>.</p>

<p>For the binary alphabet {0,1}, and choosing <script type="math/tex">n=4</script> we have the
following set of strings of length 1, 2 and 4:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0, 1, 01, 0001, 0011, 0111
</code></pre></div></div>

<p>Sorted lexicographically:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0, 0001, 0011, 01, 0111, 1
</code></pre></div></div>

<p>If we concatenate them we obtain a <a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence">De
Bruijn sequence</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000100110101111
</code></pre></div></div>

<p>A <a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence">De Bruijn sequence</a>
of order <script type="math/tex">n</script> has the property than all the substrings of length <script type="math/tex">n</script>
that are possible are contained in the De Bruijn sequence if is seen
as a cyclic sequence:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000100110101111
0000............
.0001...........
..0010..........
...0100.........
....1001........
.....0011.......
......0110......
.......1101.....
........1010....
.........0101...
..........1011..
...........0111.
............1111
0............111  =  1110
00............11  =  1100
000............1  =  1000
</code></pre></div></div>

<p>A <a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence">De Bruijn sequence</a>
is the smallest sequence that has this property but it is not unique.</p>

<p>The count of distinct De Bruijn sequences for an alphabet of <script type="math/tex">k</script> elements
and an order of <script type="math/tex">n</script> is</p>

<script type="math/tex; mode=display">\frac{(k!)^{k^{n-1}}}{k^n}</script>

<h2 id="de-bruijn-graphs">De Bruijn graphs</h2>

<p>Given an alphabet of <script type="math/tex">k</script> symbols and the strings of <script type="math/tex">n</script> symbols
we can build <script type="math/tex">k^n</script> different strings.</p>

<p>Consider these strings now nodes of a directed graph.</p>

<p>In this graph the node <script type="math/tex">u</script> connects to <script type="math/tex">v</script> if we drop the left most
symbol of <script type="math/tex">u</script> and append on the right one symbol and the result is
<script type="math/tex">v</script>.</p>

<p>In Python terms: <code class="highlighter-rouge">u[1:] + sym == v</code>.</p>

<p>The resulting edge is labeled with the appended symbol.</p>

<p>For instance, for the given binary strings 00 and 01 we have:</p>

<figure><figcaption><span></span></figcaption><object align="middle" data="/book-of-gehn/uml/4e7ff72eb8c4bac604f61910944f34f51c7ac9aa.svg" type="image/svg+xml"></object></figure>

<p>In general for the alphabet <script type="math/tex">{0,1}</script> and the strings of length <script type="math/tex">n=2</script>
we have:</p>

<figure><figcaption><span></span></figcaption><object align="middle" data="/book-of-gehn/uml/e90a47ce7db53454142582242792fa721c7ac9aa.svg" type="image/svg+xml"></object></figure>

<p>These are the <a href="https://en.wikipedia.org/wiki/De_Bruijn_graph">De Bruijn
graphs</a>.</p>

<p>A <a href="https://en.wikipedia.org/wiki/Hamiltonian_path">Hamiltonian path</a>
over the graph generates a De Bruijn sequence of order <script type="math/tex">n</script>.</p>

<p>That’s it, visit all the <em>nodes</em> of the graph without visiting a node
twice and collect the labels of the traversed edges.</p>

<p>This forms the De Bruijn sequence of order <script type="math/tex">n</script> for the given <script type="math/tex">k</script>.</p>

<p>If instead of a Hamiltonian path we build an <a href="https://en.wikipedia.org/wiki/Eulerian_path">Euclidean
path</a>, the path
generates a De Bruijn sequence of order <script type="math/tex">n+1</script>.</p>

<p>That’s it, visit all the <em>edges</em> of the graph without traveling for the
same edge twice and collect the labels along the path.</p>

<p>This forms the De Bruijn sequence of order <script type="math/tex">n+1</script> for the given <script type="math/tex">k</script>.</p>

<h2 id="de-bruijn-sequence-construction">De Bruijn sequence construction</h2>

<p>As mentioned before we can build a De Bruijn graph and then through a
Hamiltonian or Euclidean path we can build a De Bruijn sequence.</p>

<p>But we can skip that and create the sequence directly with the <a href="/book-of-gehn/assets/debruijn-assets/debruijn.py">FMK
algorithm</a>.</p>

<p>FMK comes from the name of its authors: Fredricksen, Maiorana and Kessler.</p>

<p>A recursive version of the algorithm is shown by Frank Ruskey in his
<em>“Combinatorial Generation”</em>.</p>

<p>The algorithm can generate necklaces, Lyndon words, pre-necklaces and De
Bruijn sequences. Four in one.</p>

<p>A Python implementation can be found
<a href="/book-of-gehn/assets/debruijn-assets/debruijn.py">here</a>.</p>

<h2 id="applications">Applications</h2>

<h3 id="unlook-a-door">Unlook a door</h3>

<p>Imagine that you have a register of <script type="math/tex">n</script> bits that if it is set
to the correct value <em>unlocks</em> a door.</p>

<p>You have <script type="math/tex">2^n</script> possible combinations.</p>

<p>Typing <script type="math/tex">n</script> bits <script type="math/tex">2^n</script> times is is going to take a while
but imagine that the register allows you to <em>reuse</em> some of those bits.</p>

<p>On a new input the register shifts its content one bit to the left and
the new bit is put on the right.</p>

<p>Does this ring any bells?</p>

<p>You can use a De Bruijn sequence of order <script type="math/tex">n</script> and reading it bit by
bit you can <em>feed</em> the register.</p>

<p>You will end up testing <script type="math/tex">2^n</script> combinations but you will have to type
<strong>only 1 bit</strong> per test.</p>

<h3 id="power-of-2-mapping">Power of 2 mapping</h3>

<p>You want to map a value to each power of 2. You could use an dictionary
for this like <code class="highlighter-rouge">{2**i : vals[i] for i in range(32)}</code>.</p>

<p>A dictionary or a <em>sparse</em> array is needed because you cannot use a
dense array for this.</p>

<p>Or can we?</p>

<p>If we are limiting ourselves to power of two up to <script type="math/tex">2^{32}</script>, we only
have 32 numbers.</p>

<p>We can then generate a De Bruijn sequence of order <script type="math/tex">n</script> where <script type="math/tex">n=5</script>
(because <script type="math/tex">2^5=32</script>).</p>

<p>This sequence will contain <script type="math/tex">2^5=32</script> different substrings.</p>

<p>Now, remember that multiplying a number by <script type="math/tex">2^i</script> is the same than
shifting the number by <script type="math/tex">i</script>.</p>

<p>If we read the <script type="math/tex">n</script> most significant bits of the shifted sequence we
will have a substring that is unique for the given shift <script type="math/tex">i</script> and
therefore for <script type="math/tex">2^i</script>.</p>

<p>The <script type="math/tex">n</script> most significant bits forms the index of our dense array.</p>

<p>With <script type="math/tex">n=5</script> we only need an array of <script type="math/tex">32</script> elements.</p>

<h2 id="dna-reading">DNA reading</h2>

<p>And yes, this is used in <a href="https://en.wikipedia.org/wiki/DNA_read_errors">DNA
reading</a> too.</p>



    </article>
    <span class="print-footer">Necklaces, Lyndon words and De Bruijn Sequences - February 15, 2021 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
