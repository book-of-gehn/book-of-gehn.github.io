<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>High Precision Timers (userspace)</title>
  <meta name="description" content="You want to measure the time that it takes foo() to run soyou do the following:void experiment() {    uint64_t begin = now();    foo();    uint64_t end = now...">

  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]},
	TeX: {
	  Macros: {
            
	  }
	}
      });
    </script>
    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js' async></script>
    
  

  
    <script
       src="https://code.jquery.com/jquery-3.4.1.min.js"
       integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
       crossorigin="anonymous"></script>
  

  

    
      <script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js' ></script>
    

    
      <script src="https://d3js.org/d3.v4.min.js"></script>
    

    <script src='/book-of-gehn/js/venn/venn.min.js'></script>
    <script src='/book-of-gehn/js/venn/helper.js'></script>

    <script src='/book-of-gehn/js/fix_syntax_highlight.js'></script>
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/tufte.css">
  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/latex.css">

  <link rel="canonical" href="/book-of-gehn/articles/2021/02/27/High-Precision-Timers.html">

  <link rel="stylesheet" type="text/css" href="/book-of-gehn/css/all.min.css">

  <link type="application/atom+xml" rel="alternate" href="/book-of-gehn/feed.xml" title="The Book of Gehn" />
</head>

  <body>
    <header>
	
		<h1 class="header-title"><a href="/book-of-gehn/">The Book of Gehn</a></h1>
		
		
	

    

    
</header>

    <article class="group">
      <h1>High Precision Timers (userspace)</h1>
<p class="subtitle">February 27, 2021</p>

<p>You want to measure the time that it takes <code class="highlighter-rouge">foo()</code> to run so
you do the following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">experiment</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">now</span><span class="p">();</span>
    <span class="n">foo</span><span class="p">();</span>
    <span class="kt">uint64_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">now</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Elapsed: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The question is, what <code class="highlighter-rouge">now()</code> function you would use?<!--more--></p>

<p><label for="mn-eb29b55ad6d0f41601d1d47bf7527f71" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-eb29b55ad6d0f41601d1d47bf7527f71" class="margin-toggle" /><span class="marginnote">You could read a CPU register that implements the clock in hardware.
Beware, however, that the read may not be cheap and the clock
may not have the precision that you need.
<br />
Also, the register may be per CPU: to make it work you need to
ensure that <code class="highlighter-rouge">experiment()</code> does not migrate to another CPU.
<br />
See <a href="https://github.com/wcohen/libpfm4">libpfm4</a>.
 </span></p>

<p>There are some options available:</p>

<ul>
  <li><code class="highlighter-rouge">time()</code> from <code class="highlighter-rouge">time.h</code></li>
  <li><code class="highlighter-rouge">gettimeofday()</code> from <code class="highlighter-rouge">sys/time.h</code></li>
  <li><code class="highlighter-rouge">getrusage()</code> from <code class="highlighter-rouge">sys/time.h</code> and <code class="highlighter-rouge">sys/resource.h</code></li>
  <li><code class="highlighter-rouge">clock_gettime()</code> from <code class="highlighter-rouge">time.h</code></li>
</ul>

<p>However not all of them are as suitable for the task as they may seem.</p>

<h2 id="test-escenario">Test escenario</h2>

<p>The idea is to call a particular clock several times in a tight loop.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">size_t</span> <span class="n">rounds</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span> <span class="k">const</span> <span class="n">times1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">times1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rounds</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rounds</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">times1</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">print_nsec_resolution</span><span class="p">(</span><span class="n">rounds</span><span class="p">,</span> <span class="s">"mono"</span><span class="p">,</span> <span class="n">times1</span><span class="p">);</span>
</code></pre></div></div>

<p><label for="mn-cb27feb9f66d3ce8a8f57233b20f789c" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-cb27feb9f66d3ce8a8f57233b20f789c" class="margin-toggle" /><span class="marginnote">If the clock jumps <em>backwards</em>, this function will print a <em>huge</em>
number and not a negative value.
 </span></p>

<p>The <code class="highlighter-rouge">print_*</code> functions will print the measurements normalized: no
matter the clock’s resolution, the printed value will be in nanoseconds
and to get comparable results the values are respect the first
measurement.</p>

<p>In other words:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">times1</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000000000</span><span class="p">;</span> <span class="c1">// seconds as nanoseconds</span>
<span class="n">ref</span> <span class="o">+=</span> <span class="n">times1</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tv_nsec</span><span class="p">;</span> <span class="c1">// plus the nanoseconds</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rounds</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">times1</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000000000</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">+=</span> <span class="n">times1</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tv_nsec</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%s %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The full code can be found
<a href="/book-of-gehn/assets/timing-assets/clocks.c">here</a>.</p>

<h2 id="evaluation">Evaluation</h2>

<p>Compiled and executed with 10000 rounds each clock, it generated 70000
lines.</p>

<p><label for="mn-f54216808c493c3f80dc6392ed4cbef4" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-f54216808c493c3f80dc6392ed4cbef4" class="margin-toggle" /><span class="marginnote">The use of <code class="highlighter-rouge">dtype={"clock type": "category"}</code> is important. Pandas
will load these strings and it will create a category for each distinct
label which internally is represented as an integer.
<br />
This reduces by two orders of magnitud the memory usage
(<code class="highlighter-rouge">d.memory_usage(True, True)</code> to compare them).
<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/scale.html">Pandas
reference</a>
 </span></p>

<p>Each line is prefixed with a string that labels the clock type.</p>

<p>The output can be loaded with <code class="highlighter-rouge">pandas</code> as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
<span class="o">...</span>         <span class="n">fname</span><span class="p">,</span>
<span class="o">...</span>         <span class="n">sep</span><span class="o">=</span><span class="s">' '</span><span class="p">,</span>
<span class="o">...</span>         <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
<span class="o">...</span>         <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">'clock type'</span><span class="p">,</span> <span class="s">'tval'</span><span class="p">],</span>
<span class="o">...</span>         <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s">'clock type'</span><span class="p">:</span> <span class="s">'category'</span><span class="p">})</span>
</code></pre></div></div>

<p>It makes sense to analyze not the time returned by each call but the
difference between two consecutive calls. This highlights how much
stable is the clock and how much delay adds the call.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s">'clock type'</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">selected_rows</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">'clock type'</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span>
<span class="o">...</span>     <span class="n">differences</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">selected_rows</span><span class="p">][</span><span class="s">'tval'</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
<span class="o">...</span>     <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selected_rows</span><span class="p">,</span> <span class="s">'tval'</span><span class="p">]</span> <span class="o">=</span> <span class="n">differences</span>
</code></pre></div></div>

<p>The full code can be found
<a href="/book-of-gehn/assets/timing-assets/analyze.py">here</a>.</p>

<p>Let’s review what we’ve got.</p>

<h3 id="time"><code class="highlighter-rouge">time()</code></h3>

<p><code class="highlighter-rouge">time()</code> has a resolution of a second, so it is a <em>no-go</em> to measure things
of the order of the microsecond or less.</p>

<p>But for completeness I tested <code class="highlighter-rouge">time()</code> anyways and what I found
it was a surprise:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Clock type: time
         tval
count  9999.0
mean      0.0
std       0.0
min       0.0
25%       0.0
50%       0.0
75%       0.0
max       0.0
</code></pre></div></div>

<p>If I run <code class="highlighter-rouge">time()</code> in tight <code class="highlighter-rouge">for</code> loop, it returns always the same value,
no matter how many times the loop iterates.</p>

<p>I thought that it was a bug but nope, when I run it with <code class="highlighter-rouge">gdb</code> it works as
expected.</p>

<p>Weird.</p>

<h3 id="gettimeofday"><code class="highlighter-rouge">gettimeofday()</code></h3>

<p><label for="mn-dc0b3eefb4998a6ca1169da11ae5af81" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-dc0b3eefb4998a6ca1169da11ae5af81" class="margin-toggle" /><span class="marginnote">This can be explained due its implementation: instead of doing a
syscall, a call to <code class="highlighter-rouge">gettimeofday()</code> calls a snippet of code in user
space.
<br />
See more about <a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-3.html">vsyscall and vDSO here</a>
 </span></p>

<p><code class="highlighter-rouge">gettimeofday()</code> shown the best performance: the worst time measured
between two consecutive calls is just 2 microseconds, which it is twice
the minimum resolution of the function.</p>

<p>Fast but it is also super imprecise.</p>

<p>More than 75% of the differences between two consecutive measurements
are zero which means that <code class="highlighter-rouge">gettimeofday()</code> returns a cached value and it
is updated very infrequently.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clock type: tofd
              tval
count  9999.000000
mean     27.102710
std     166.646544
min       0.000000
25%       0.000000
50%       0.000000
75%       0.000000
max    2000.000000
</code></pre></div></div>

<p>In addition to its intrinsic imprecision, <code class="highlighter-rouge">gettimeofday()</code> is <strong>not
guaranteed to be monotonically increasing</strong>. So you can see <em>jumps</em> to
the future or event to the past.</p>

<p>This is because <code class="highlighter-rouge">gettimeofday()</code> is in sync with external sources of
time like NTP. The user may even change it running <code class="highlighter-rouge">date</code>.</p>

<p>Fast but not useful to measure differences of time.</p>

<h3 id="getrusage"><code class="highlighter-rouge">getrusage()</code></h3>

<p>Something similar happens with <code class="highlighter-rouge">getrusage()</code>: it is slightly slower than
<code class="highlighter-rouge">gettimeofday()</code> but it is still super fast (7 microseconds) but returns
cached values (at least half of the times).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Clock type: ruse
              tval
count  9999.000000
mean    524.152415
std     656.260508
min       0.000000
25%       0.000000
50%       0.000000
75%    1000.000000
max    7000.000000
</code></pre></div></div>

<h3 id="clock_gettime"><code class="highlighter-rouge">clock_gettime()</code></h3>

<p><label for="mn-76401935f6d8c10a405345e8f13e5b88" class="margin-toggle"> ⊕</label><input type="checkbox" id="mn-76401935f6d8c10a405345e8f13e5b88" class="margin-toggle" /><span class="marginnote">See also the <a href="https://www.python.org/dev/peps/pep-0418/#time-monotonic">PEP 418</a>.
 </span></p>

<p>The manpage describes four kind of clocks that may work:</p>

<ul>
  <li><code class="highlighter-rouge">CLOCK_MONOTONIC</code>: monotonic time but it may be affected by
incremental changes done by <code class="highlighter-rouge">adjtime</code> or NTP.</li>
  <li><code class="highlighter-rouge">CLOCK_MONOTONIC_RAW</code>: like <code class="highlighter-rouge">CLOCK_MONOTONIC</code> but it is not affected by
<code class="highlighter-rouge">adjtime</code> or NTP. Uses hardware-specific.</li>
  <li><code class="highlighter-rouge">CLOCK_PROCESS_CPUTIME_ID</code>: per process clock that measures the
CPU time for the process (among all the threads).</li>
  <li><code class="highlighter-rouge">CLOCK_THREAD_CPUTIME_ID</code>: per thread clock that measures the
CPU time for that particular thread.</li>
</ul>

<p><code class="highlighter-rouge">clock_gettime()</code> is the only that returned values that make sense
and <code class="highlighter-rouge">CLOCK_MONOTONIC</code> is the winner.</p>

<p>It has the smallest elapsed time (80 nanoseconds) and it has a
dispersion of the values of few nanoseconds.</p>

<p>This can be seen in the percentiles 80, 84, 85, 86 nanoseconds.</p>

<p><code class="highlighter-rouge">CLOCK_PROCESS_CPUTIME_ID</code> and <code class="highlighter-rouge">CLOCK_THREAD_CPUTIME_ID</code> are in the
second place.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         MONOTONIC    MONOTONIC_RAW   PROCESS_CPUTIME    THREAD_CPUTIME
              tval             tval              tval              tval
count  9999.000000      9999.000000       9999.000000       9999.000000
mean    102.900290       773.215422        387.565257        379.232923
std     295.741321       200.428225        216.037233        210.391130
min      80.000000       709.000000        366.000000        358.000000
25%      84.000000       719.000000        374.000000        367.000000
50%      85.000000       723.000000        377.000000        370.000000
75%      86.000000       728.000000        401.000000        391.000000
max    8019.000000     13532.000000      17392.000000      17572.000000
</code></pre></div></div>

<p>In all the cases the clocks are quite stable and the outliers are
probably due noise in the system.</p>

<h2 id="conclusions">Conclusions</h2>

<p><code class="highlighter-rouge">clock_gettime()</code> with <code class="highlighter-rouge">CLOCK_MONOTONIC</code> is the winner, at least in my
4.19 kernel, with a minimum delta of 80 to 86 nanoseconds.</p>

<p>In second place <code class="highlighter-rouge">clock_gettime()</code> with <code class="highlighter-rouge">CLOCK_PROCESS_CPUTIME_ID</code> or
<code class="highlighter-rouge">CLOCK_THREAD_CPUTIME_ID</code>. Good performance, roughly 4 or 5 times slower
than <code class="highlighter-rouge">CLOCK_MONOTONIC</code>.</p>

<p><code class="highlighter-rouge">clock_gettime()</code> with <code class="highlighter-rouge">CLOCK_MONOTONIC_RAW</code> is not bad but it is at
least 8 times slower than <code class="highlighter-rouge">CLOCK_MONOTONIC</code>.</p>

<p>The rest of the clocks are <strong>not</strong> useful.</p>




    </article>
    <span class="print-footer">High Precision Timers (userspace) - February 27, 2021 - Gehn</span>
    <footer>
    <hr class="slender">
    <div class="credits">
        <span>&copy; 2021
            
            Gehn
        </span></br>
            <a style="text-decoration: none;" href="/book-of-gehn/feed.xml"><img height="16px" width="16px" src="/book-of-gehn/assets/blog-assets/rss-32px.png" /></a>
        <br>
        

    
    </div>
</footer>

  </body>
</html>
